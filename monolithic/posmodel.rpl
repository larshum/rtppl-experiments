type RoomMap = {
  data : [[Bool]], rows : Int, cols : Int
}

type Coordinate = { row : Int, col : Int }

type Pos = { x : Float, y : Float, direction : Float }

type Offset = { angle : Float, distance : Float, direction : Float }

type SensorData = { ofs : Offset, obs : [TSV(Dist(Float))], maxRange : Float }

const roomBlockWidth : Float = 0.1
const wheelCircumference : Float = 0.33
const maxSpeed : Float = 0.63
const maxSpeedRpm : Float = maxSpeed * 60.0 / wheelCircumference
const usMaxRange : Float = 4.0
const usMaxAngle : Float = 0.4363323129985824
const tofMaxRange : Float = 1.25
const tofMaxAngle : Float = 0.2617993877991494
const maxDistance : Float = 10.0
const maxSteer : Float = 20.0
const wheelbase : Float = 0.35

const zeroOffset : Offset = { angle = 0.0, distance = 0.0, direction = 0.0 }
const frontLeftOffset : Offset = {
  angle = 0.0-0.209639845874, distance = 0.240260275535, direction = 0.0
}
const frontRightOffset : Offset = {
  angle = 0.209639845874, distance = 0.240260275535, direction = 0.0
}
const rearLeftOffset : Offset = {
  angle = 0.0-2.76725903758, distance = 0.30083217913, direction = pi
}
const rearRightOffset : Offset = {
  angle = 2.76725903758, distance = 0.30083217913, direction = pi
}
const sideLeftOffset : Offset = {
  angle = 0.0-2.15879893034, distance = 0.126194294641, direction = (3.0 * pi) / 2.0
}
const sideRightOffset : Offset = {
  angle = 2.15879893034, distance = 0.126194294641, direction = pi / 2.0
}
const sensorOffsets : [Offset] = [
  frontLeftOffset, frontRightOffset, rearLeftOffset, rearRightOffset,
  sideLeftOffset, sideRightOffset
]

const inf : Float = 0.0 / 1.0
const neginf : Float = 0.0 - inf

def tan(x : Float) : Float {
  return sin(x) / cos(x)
}

def degToRad(degAngle : Float) : Float {
  return degAngle * pi / 180.0
}

def abs(x : Float) : Float {
  cond x if x < 0.0 {
    x = 0.0 - x
  } else {}
  return x
}

def maxFloat(a : Float, b : Float) : Float {
  cond res if a < b {
    res = b
  } else {
    res = a
  }
  return res
}

def sgn(x : Float) : Float {
  cond x if x < 0.0 {
    x = 0.0 - 1.0
  } else {
    cond x if x > 0.0 {
      x = 1.0
    } else {}
  }
  return x
}

def readRoomMap() : RoomMap {
  var data : [[Bool]] = readRoomMapRuntimeHelper()
  return {data = data, rows = |data|, cols = |data[0]|}
}

def posToCoordinate(p : Pos) : Coordinate {
  return {
    row = floorToInt(p.y / roomBlockWidth),
    col = floorToInt(p.x / roomBlockWidth)
  }
}

def positionAtOffset(p : Pos, ofs : Offset) : Pos {
  p.x = p.x + ofs.distance * cos(p.direction + ofs.angle)
  p.y = p.y + ofs.distance * sin(p.direction + ofs.angle)
  p.direction = p.direction + ofs.direction
  return p
}

def withinRoomBounds(m : RoomMap, p : Pos) : Bool {
  var c : Coordinate = posToCoordinate(p)
  var res : Bool = true
  cond res if ltInt(c.row, 0) || geqInt(c.row, m.rows) || ltInt(c.col, 0) || geqInt(c.col, m.cols) {
    res = false
  } else {
    res = not(m.data[c.row][c.col])
  }
  return res
}

// Computes whether a car centered at the given position is within the bounds
// of the provided map. We estimate this by verifying that the sensors in each
// direction are within the bounds of the map.
def carWithinRoomBounds(m : RoomMap, center : Pos) : Bool {
  var sensorOffsets : [Offset] = [
    frontLeftOffset, frontRightOffset, rearLeftOffset, rearRightOffset,
    sideLeftOffset, sideRightOffset
  ]
  var acc : Bool = true
  loop acc for ofs in sensorOffsets {
    cond acc if acc {
      var p : Pos = positionAtOffset(center, ofs)
      acc = withinRoomBounds(m, p)
    } else {}
  }
  return acc
}

def findFreeRoomCoordinates(m : RoomMap) : [Coordinate] {
  var blocks : [Coordinate] = []
  loop blocks for row in range(0, m.rows) {
    loop blocks for col in range(0, m.cols) {
      cond blocks if not(m.data[row][col]) {
        blocks = push(blocks, {row = row, col = col})
      } else {}
    }
  }
  return blocks
}

def absInt(x : Int) : Int {
  cond x if ltInt(x, 0) {
    x = negInt(x)
  } else {}
  return x
}

// Computes the sigma (of a normal distribution) based on the relative
// timestamp. We use this under the assumption that an observation made closer
// in time to 0 (the logically local time) should be considered more accurate.
// If the timestamp is too close to the logically local time, we use a
// pre-determined constant instead.
def timeRelativeSigma(ts : Int) : Float {
  var min : Float = 0.01
  var x : Float = intToFloat(absInt(ts)) / intToFloat(1s)
  cond x if x < min {
    x = min
  } else { }
  return x
}

// Converts a given relative timestamp, in nanoseconds, to a number in seconds.
def timestampToSeconds(ts : Int) : Float {
  return intToFloat(ts) / intToFloat(1s)
}

def cmpFloatTimestamp(l : TSV(Float), r : TSV(Float)) : Int {
  var acc = 0
  cond acc if gtInt(timestamp(l), timestamp(r)) {
    acc = 1
  } else {
    cond acc if ltInt(timestamp(l), timestamp(r)) {
      acc = negInt(1)
    } else {}
  }
  return acc
}

def maxFloatTimestamp(tsvs : [TSV(Float)]) : TSV(Float) {
  var acc = tsvs[0]
  loop acc for tsv in tsvs {
    cond acc if ltInt(cmpFloatTimestamp(acc, tsv), 0) {
      acc = tsv
    } else {}
  }
  return acc
}

def maxValue(s : [TSV(Float)]) : Float {
  var acc = neginf
  loop acc for x in s {
    var v = value(x)
    cond acc if v > acc {
      acc = v
    } else {}
  }
  return acc
}

def minValue(s : [TSV(Float)]) : Float {
  var acc = inf
  loop acc for x in s {
    var v = value(x)
    cond acc if v < acc {
      acc = v
    } else {}
  }
  return acc
}

def maxDistPosTimestamp(acc : TSV(Dist(Pos)), tsvs : [TSV(Dist(Pos))]) : TSV(Dist(Pos)) {
  loop acc for tsv in tsvs {
    cond acc if ltInt(timestamp(acc), timestamp(tsv)) {
      acc = tsv
    } else {}
  }
  return acc
}

def cmpFloat(l : Float, r : Float) : Int {
  var acc = 0
  cond acc if l > r {
    acc = 1
  } else {
    cond acc if l < r {
      acc = negInt(1)
    } else {}
  }
  return acc
}

def medianOfLastThreeFloatTsv(tsvs : [TSV(Float)]) : Float {
  var n = |tsvs|
  var a = value(tsvs[subInt(n, 3)])
  var b = value(tsvs[subInt(n, 2)])
  var c = value(tsvs[subInt(n, 1)])
  var res = 0.0
  cond res if a < b {
    cond res if b < c {
      res = b
    } else {
      res = c
    }
  } else {
    cond res if a < c {
      res = a
    } else {
      res = c
    }
  }
  return res
}

def allOutOfRange(distanceObs : [TSV(Float)], maxRange : Float) : Bool {
  var acc = true
  loop acc for tsv in distanceObs {
    cond acc if value(tsv) < maxRange {
      acc = false
    } else {}
  }
  return acc
}

model frontRearDistanceModel(distanceObs : [TSV(Float)],
                             saObs : [TSV(Float)], speedEst : TSV(Float),
                             maxSensorRange : Float, dir : Float) : Float {
  // NOTE(larshum, 2023-05-16): If all distance observations are outside of the
  // range, the true distance can be anywhere beyond the maximum range of the
  // sensor.
  var res = 0.0
  cond res if allOutOfRange(distanceObs, maxSensorRange) {
    res = maxSensorRange
  } else {
    var v = value(speedEst)
    sample m ~ Gaussian(dir * v, 0.1)
    sample b ~ Uniform(0.0, maxDistance)
    sample sigma ~ Gamma(1.0, 1.0)
    cond res if minValue(saObs) == maxValue(saObs) {
      loop for tsv in distanceObs {
        var ts = timestampToSeconds(timestamp(tsv))
        observe value(tsv) ~ Gaussian(m * ts + b, sigma)
      }
      res = b
    } else {
      res = medianOfLastThreeFloatTsv(distanceObs)
    }
  }

  return res
}

def takeNMostRecent(a : [TSV(Float)], n : Int) : [TSV(Float)] {
  a = sort(cmpFloatTimestamp, a)
  cond a if gtInt(|a|, n) {
    var res = []
    loop res for i in range(0, n) {
      res = push(res, a[subInt(|a|, subInt(n, i))])
    }
    a = res
  } else {}
  return a
}

template frontRearDistance(period : Int, dir : Float) {
  input distObs : Float
  input steeringAngleObs : Float
  input speedEst : Dist(Float)
  output distEst : Dist(Float)
  var lastSpeed = tsv(0, 0.0)
  var lastObs = []
  loop lastSpeed {
    sdelay period
    read distObs to obs
    read steeringAngleObs to saObs
    read speedEst to speed
    cond lastObs if gtInt(|obs|, 0) {
      lastObs = takeNMostRecent(concat(lastObs, obs), 10)
    } else {}
    lastSpeed = maxFloatTimestamp(concat([lastSpeed], speed))
    cond if (minValue(saObs) == 0.0 && maxValue(saObs) == 0.0) || geqInt(|lastObs|, 3) {
      infer frontRearDistanceModel(lastObs, saObs, lastSpeed, usMaxRange, dir)
        particles 1000
        to d
      write d to distEst
    } else {}
  }
}

model sideDistanceModel(distObs : [TSV(Float)], maxSensorRange : Float) : Float {
  var res = 0.0
  cond res if allOutOfRange(distObs, maxSensorRange) {
    res = maxSensorRange
  } else {
    res = medianOfLastThreeFloatTsv(distObs)
  }
  return res
}

template sideDistance(period : Int) {
  input distObs : Float
  output distEst : Dist(Float)
  var lastObs = []
  loop lastObs {
    sdelay period
    read distObs to obs
    cond lastObs if gtInt(|obs|, 0) {
      lastObs = takeNMostRecent(concat(lastObs, obs), 3)
    } else {}
    cond if geqInt(|lastObs|, 3) {
      infer sideDistanceModel(lastObs, tofMaxRange) particles 1000 to d
      write d to distEst
    } else {}
  }
}

// We choose the initial position by choosing a random block of the map,
// and then sampling coordinates within the block. We assume that the initial
// direction of the car relative to the map is known, and that the car is
// stationary when the model starts running.
model initialPositionModel(blocks : [Coordinate]) : Pos {
  //var c : Coordinate = randElemExn(blocks)
  //var x : Float = intToFloat(c.col) * roomBlockWidth
  //var y : Float = intToFloat(c.row) * roomBlockWidth
  //assume xOfs ~ Uniform(0.0, roomBlockWidth)
  //assume yOfs ~ Uniform(0.0, roomBlockWidth)
  //assume d ~ Uniform(0.0, 2.0 * pi)
  //return { x = x + xOfs, y = y + yOfs, direction = d }
  return {x = 3.58, y = 3.6, direction = 1.5*pi}
}

// The position denotes our belief of the center of the car. The cone angle
// represents the cone in which we observe distances - we shoot three
// particles, one from each side of the cone plus the a beam from the center.
// The first of these to collide determines our estimated distance.
def estimateDistance(ofs : Offset, coneAngle : Float, p : Pos,
                     inBounds : Pos -> Bool) : Float {
  var eps = 0.1
  p1 = positionAtOffset(p, ofs)
  p2 = p1
  p3 = p1
  p2.direction = p1.direction + coneAngle
  p3.direction = p1.direction - coneAngle
  var acc = {d = 0.0, p1 = p1, p2 = p2, p3 = p3}
  loop acc while inBounds(acc.p1) && inBounds(acc.p2) && inBounds(acc.p3) {
    var p1 = acc.p1
    p1.x = p1.x + eps * cos(p1.direction)
    p1.y = p1.y + eps * sin(p1.direction)
    acc.p1 = p1
    var p2 = acc.p2
    p2.x = p2.x + eps * cos(p2.direction)
    p2.y = p2.y + eps * sin(p2.direction)
    acc.p2 = p2
    var p3 = acc.p3
    p3.x = p3.x + eps * cos(p3.direction)
    p3.y = p3.y + eps * sin(p3.direction)
    acc.p3 = p3
    acc.d = acc.d + eps
  }
  return acc.d
}

def computePos(p0 : Pos, l : Float, r : Float, steeringAngle : Float) : Pos {
  // If the current steering angle is zero, the car is driving in a straight
  // line. In this case, just update x and y based on the direction it is
  // travelling in. Otherwise, the car will drive along the arc of a circle, so
  // we estimate the position it ends up in.
  cond p1 if steeringAngle == 0.0 {
    p1 = {
      x = p0.x + l * cos(p0.direction),
      y = p0.y + l * sin(p0.direction),
      direction = p0.direction
    }
  } else {
    // If steering angle is negative, we are steering counterclockwise.
    var d = p0.direction
    cond p1 if steeringAngle < 0.0 {
      p1 = {
        x = p0.x + r * (sin(d) - sin(d - l / r)),
        y = p0.y + r * (cos(d - l / r) - cos(d)),
        direction = d - l / r
      }
    } else {
      p1 = {
        x = p0.x + r * (sin(d + l / r) - sin(d)),
        y = p0.y + r * (cos(d) - cos(d + l / r)),
        direction = d + l / r
      }
    }
  }
  return p1
}

def smallFrontAngle(m : RoomMap, p : Pos) : Bool {
  var inBounds : Pos -> Bool = withinRoomBounds(m)
  var ld = estimateDistance(frontLeftOffset, 0.0, p, inBounds)
  var rd = estimateDistance(frontRightOffset, 0.0, p, inBounds)
  return abs(ld - rd) / maxFloat(ld, rd) > 0.2
}

def smallRearAngle(m : RoomMap, p : Pos) : Bool {
  var inBounds : Pos -> Bool = withinRoomBounds(m)
  var ld = estimateDistance(rearLeftOffset, 0.0, p, inBounds)
  var rd = estimateDistance(rearRightOffset, 0.0, p, inBounds)
  return abs(ld - rd) / maxFloat(ld, rd) > 0.2
}

model positionModel(m : RoomMap, prior : TSV(Dist(Pos)), flEst : [TSV(Dist(Float))],
                    frEst : [TSV(Dist(Float))], rlEst : [TSV(Dist(Float))],
                    rrEst : [TSV(Dist(Float))], lEst : [TSV(Dist(Float))],
                    rEst : [TSV(Dist(Float))], speedEst : TSV(Float),
                    saObs : TSV(Float)) : Pos {

  sample posPrev ~ value(prior)
  sample sigma ~ Gamma(0.5, 1.0)

  cond v if value(speedEst) == 0.0 {
    v = 0.0
  } else {
    v = maxSpeed
  }
  // We assume the most recent steering angle is the current steering angle. We
  // compute this based on the observed behavior of the wheels when given
  // different steering inputs.
  // NOTE(larshum, 2023-05-23): We swap the sign of the steering angle because
  // the y-axis of the map is inverted (the upper left corner of the PNG is
  // (0,0)).
  cond sa if value(saObs) > 0.0 {
    sa = 0.03 - degToRad(value(saObs) / maxSteer * 0.186)
  } else {
    sa = 0.03 + degToRad(value(saObs) / maxSteer * 0.243)
  }
  var turnRadius = wheelbase / tan(sa)
  cond turnRadius if turnRadius < 0.0 {
    turnRadius = 0.0 - turnRadius
  } else {}

  // NOTE(larshum, 2023-05-25): We always consider sensor data from the sides.
  // For the front and rear sensors, we ignore the data if the estimated
  // distance between the sensors is too large, as we cannot rely on such
  // observations for the sound-based sensors.
  var sensorData : [SensorData] = [
    { ofs = sideLeftOffset, obs = lEst, maxRange = tofMaxRange, maxAngle = tofMaxAngle },
    { ofs = sideRightOffset, obs = rEst, maxRange = tofMaxRange, maxAngle = tofMaxAngle }
  ]
  cond sensorData if smallFrontAngle(m, posPrev) {
    sensorData = push(sensorData,
    { ofs = frontLeftOffset, obs = flEst, maxRange = usMaxRange, maxAngle = usMaxAngle }
    )
    sensorData = push(sensorData, 
    { ofs = frontRightOffset, obs = frEst, maxRange = usMaxRange, maxAngle = usMaxAngle }
    )
  } else {}
  cond sensorData if smallRearAngle(m, posPrev) {
    sensorData = push(sensorData,
    { ofs = rearLeftOffset, obs = rlEst, maxRange = usMaxRange, maxAngle = usMaxAngle }
    )
    sensorData = push(sensorData,
    { ofs = rearRightOffset, obs = rrEst, maxRange = usMaxRange, maxAngle = usMaxAngle }
    )
  } else {}

  var inBounds : Pos -> Bool = withinRoomBounds(m)
  loop for s in sensorData {
    loop for tsv in s.obs {
      var distTravelled = v * timestampToSeconds(subInt(timestamp(tsv), timestamp(prior)))
      var pos = computePos(posPrev, distTravelled, turnRadius, sa)
      var expectedDist = estimateDistance(s.ofs, s.maxAngle, pos, inBounds)
      cond expectedDist if expectedDist > s.maxRange {
        expectedDist = s.maxRange
      } else {}
      sample estDist ~ value(tsv)
      observe estDist ~ Gaussian(expectedDist, sigma)
    }
  }

  var dist = v * timestampToSeconds(subInt(0, timestamp(prior)))
  var pos = computePos(posPrev, dist, turnRadius, sa)
  cond if not(carWithinRoomBounds(m, pos)) {
    degenerate
  } else {}
  return pos
}

template positionEstimate(period : Int) {
  input frontLeft : Float
  input frontRight : Float
  input rearLeft : Float
  input rearRight : Float
  input left : Float
  input right : Float
  input lspeed : Float
  input rspeed : Float
  input steeringAngle : Float
  output posEst : Dist(Pos)

  var posBudget : Int = subInt(period, 500ms)
  var m : RoomMap = readRoomMap()
  var blocks : [Coordinate] = findFreeRoomCoordinates(m)
  infer initialPositionModel(blocks) particles 1000 to d
  var acc = {
    speed = tsv(0, 0.0),
    d = tsv(0, d),
    sa = tsv(0, 0.0),
    flobs = [],
    frobs = [],
    rlobs = [],
    rrobs = [],
    lobs = [],
    robs = []
  }
  loop acc {
    write value(acc.d) to posEst
    sdelay period
    read steeringAngle to saObs
    cond acc if gtInt(|saObs|, 0) {
      acc.sa = maxFloatTimestamp(saObs)
    } else {}
    read lspeed to speedL
    read rspeed to speedR
    acc.speed = maxFloatTimestamp(concat([acc.speed], concat(speedL, speedR)))
    cond acc if value(acc.speed) == 0.0 {
      acc.speed = tsv(0, 0.0)
    } else {
      acc.speed = tsv(0, maxSpeed)
    }

    read frontLeft to flObs
    cond acc if gtInt(|flObs|, 0) {
      acc.flobs = takeNMostRecent(concat(acc.flobs, flObs), 10)
    } else {}
    infer frontRearDistanceModel(acc.flobs, [acc.sa], acc.speed, usMaxRange, 0.0 - 1.0)
      particles 1000 to flEst
    read frontRight to frObs
    cond acc if gtInt(|frObs|, 0) {
      acc.frobs = takeNMostRecent(concat(acc.frobs, frObs), 10)
    } else {}
    infer frontRearDistanceModel(acc.frobs, [acc.sa], acc.speed, usMaxRange, 0.0 - 1.0)
      particles 1000 to frEst
    read rearLeft to rlObs
    cond acc if gtInt(|rlObs|, 0) {
      acc.rlobs = takeNMostRecent(concat(acc.rlobs, rlObs), 10)
    } else {}
    infer frontRearDistanceModel(acc.rlobs, [acc.sa], acc.speed, usMaxRange, 1.0)
      particles 1000 to rlEst
    read rearRight to rrObs
    cond acc if gtInt(|rrObs|, 0) {
      acc.rrobs = takeNMostRecent(concat(acc.rrobs, rrObs), 10)
    } else {}
    infer frontRearDistanceModel(acc.rrobs, [acc.sa], acc.speed, usMaxRange, 1.0)
      particles 1000 to rrEst
    read left to lObs
    cond acc if gtInt(|lObs|, 0) {
      acc.lobs = takeNMostRecent(concat(acc.lobs, lObs), 3)
    } else {}
    cond lEst if geqInt(|acc.lobs|, 3) {
      infer sideDistanceModel(acc.lobs, tofMaxRange) particles 1000 to d
      lEst = [tsv(0, d)]
    } else {
      lEst = []
    }
    read right to rObs
    cond acc if gtInt(|rObs|, 0) {
      acc.robs = takeNMostRecent(concat(acc.robs, rObs), 3)
    } else {
    }
    cond rEst if geqInt(|acc.robs|, 3) {
      infer sideDistanceModel(acc.robs, tofMaxRange) particles 1000 to d
      rEst = [tsv(0, d)]
    } else {
      rEst = []
    }
    infer positionModel(m, acc.d, [tsv(0, flEst)], [tsv(0, frEst)], [tsv(0, rlEst)], [tsv(0, rrEst)], lEst, rEst,
                             acc.speed, acc.sa)
      budget posBudget to d
    acc.d = tsv(0, d)
  }
}

def clamp(v : Float, lo : Float, hi : Float) : Float {
  cond v if v < lo {
    v = lo
  } else {
    cond v if v > hi {
      v = hi
    } else {}
  }
  return v
}

model brakeDistanceModel(m : RoomMap, pos : TSV(Dist(Pos)), speed : TSV(Float)) : Float {
  sample p ~ value(pos)
  var v = value(speed)

  // Estimate the current position based on our position and speed estimates.
  var dist = v * timestampToSeconds(subInt(0, timestamp(pos)))
  var currPos = {
    x = p.x + dist * cos(p.direction),
    y = p.y + dist * sin(p.direction),
    direction = p.direction
  }

  // Compute the distance needed to brake if we start now.
  // TODO: tune this for the car rather than the simulator.
  var brakeDist = 5.0 * v * v

  // Compute the distance until the car crashes given that it keeps driving in
  // its current direction.
  var inBounds : Pos -> Bool = carWithinRoomBounds(m)
  // TODO: choose the cone angle with more care here...
  var crashDist = estimateDistance(zeroOffset, 0.25, currPos, inBounds)
  return crashDist - brakeDist
}

def medianValue(x : {s : [Float], w : [Float]}) : Float {
  var s : [Float] = []
  var xs : [Float] = x.s
  loop s for i in range(0, |xs|) {
    s = push(s, xs[i])
  }
  s = sort(cmpFloat, s)
  return s[divInt(|s|, 2)]
}

// The brake estimation determines how far ahead in terms of distance the car
// needs to brake to avoid collision. The provided safety margin determines how
// much earlier (in terms of distance) the emergency brake is activated. For
// example, if the car has to brake in 0.1m and the safety margin is 0.2m, the
// task will signal to activate the emergency brakes.
template brakeEstimate(period : Int, safetyMargin : Float) {
  input pos : Dist(Pos)
  input lspeed : Float
  input rspeed : Float
  output brake : Float
  var m : RoomMap = readRoomMap ()
  var blocks : [Coordinate] = findFreeRoomCoordinates(m)
  infer initialPositionModel(blocks) particles 1000 to d
  var acc = {
    speed = tsv(0, 0.0),
    pos = tsv(0, d)
  }
  // Wait a while until our first estimation, as the first position estimates
  // are highly inaccurate.
  sdelay 5s
  loop acc {
    read pos to posEst
    read lspeed to speedL
    read rspeed to speedR
    acc.pos = maxDistPosTimestamp(acc.pos, posEst)
    acc.speed = maxFloatTimestamp(concat([acc.speed], concat(speedL, speedR)))
    cond acc if value(acc.speed) == 0.0 {
      acc.speed = tsv(0, 0.0)
    } else {
      acc.speed = tsv(0, maxSpeed)
    }
    infer brakeDistanceModel(m, acc.pos, acc.speed) particles 1000 to d
    cond if medianValue(samples d) < safetyMargin {
      write 0.0 to brake
    } else {}
    sdelay period
  }
}

system {
  // Distance sensors
  sensor frontLeft : Float
  sensor frontRight : Float
  sensor rearLeft : Float
  sensor rearRight : Float
  sensor sideLeft : Float
  sensor sideRight : Float

  // Wheel sensors
  sensor speedLeft : Float
  sensor speedRight : Float
  sensor steeringAngle : Float

  // Brake actuator - determines whether to brake or not
  actuator brake : Float

  task est = positionEstimate(1s)
  task brake = brakeEstimate(250ms, 0.1)

  speedLeft -> est.lspeed
  speedRight -> est.rspeed
  frontLeft -> est.frontLeft
  frontRight -> est.frontRight
  rearLeft -> est.rearLeft
  rearRight -> est.rearRight
  sideLeft -> est.left
  sideRight -> est.right
  steeringAngle -> est.steeringAngle

  speedLeft -> brake.lspeed
  speedRight -> brake.rspeed
  est.posEst -> brake.pos

  brake.brake -> brake
}
