type RoomMap = {
  data : [[Bool]], rows : Int, cols : Int
}

type Coordinate = {row : Int, col : Int}

type Pos = { x : Float, y : Float, direction : Float }

type Offset = { angle : Float, distance : Float, direction : Float }

type SensorData = { ofs : Offset, obs : [TSV(Dist(Float))], maxRange : Float }

const roomBlockWidth : Float = 0.1
const maxSpeed : Float = 0.5
const maxAcceleration : Float = 0.2
const wheelCircumference : Float = 0.35
const usMaxRange : Float = 4.0
const tofMaxRange : Float = 2.0

const zeroOffset : Offset = { angle = 0.0, distance = 0.0, direction = 0.0 }
const frontLeftOffset : Offset = {
  angle = 0.0-0.209639845874, distance = 0.240260275535, direction = 0.0
}
const frontRightOffset : Offset = {
  angle = 0.209639845874, distance = 0.240260275535, direction = 0.0
}
const rearLeftOffset : Offset = {
  angle = 0.0-2.76725903758, distance = 0.30083217913, direction = pi
}
const rearRightOffset : Offset = {
  angle = 2.76725903758, distance = 0.30083217913, direction = pi
}
const sideLeftOffset : Offset = {
  angle = 0.0-2.15879893034, distance = 0.126194294641, direction = (3.0 * pi) / 2.0
}
const sideRightOffset : Offset = {
  angle = 2.15879893034, distance = 0.126194294641, direction = pi / 2.0
}
const sensorOffsets : [Offset] = [
  frontLeftOffset, frontRightOffset, rearLeftOffset, rearRightOffset,
  sideLeftOffset, sideRightOffset
]

def readRoomMap() : RoomMap {
  var data : [[Bool]] = readRoomMapRuntimeHelper()
  return {data = data, rows = |data|, cols = |data[0]|}
}

def posToCoordinate(p : Pos) : Coordinate {
  return {
    row = floorToInt(p.y / roomBlockWidth),
    col = floorToInt(p.x / roomBlockWidth)
  }
}

def positionAtOffset(p : Pos, ofs : Offset) : Pos {
  p.x = p.x + ofs.distance * cos(p.direction + ofs.angle)
  p.y = p.y + ofs.distance * sin(p.direction + ofs.angle)
  p.direction = p.direction + ofs.direction
  return p
}

def withinRoomBounds(m : RoomMap, p : Pos) : Bool {
  var c : Coordinate = posToCoordinate(p)
  var res : Bool = true
  cond res if ltInt(c.row, 0) || geqInt(c.row, m.rows) || ltInt(c.col, 0) || geqInt(c.col, m.cols) {
    res = false
  } else {
    res = not(m.data[c.row][c.col])
  }
  return res
}

// Computes whether a car centered at the given position is within the bounds
// of the provided map. We estimate this by verifying that the sensors in each
// direction are within the bounds of the map.
def carWithinRoomBounds(m : RoomMap, center : Pos) : Bool {
  var sensorOffsets : [Offset] = [
    frontLeftOffset, frontRightOffset, rearLeftOffset, rearRightOffset,
    sideLeftOffset, sideRightOffset
  ]
  var acc : Bool = true
  loop acc for ofs in sensorOffsets {
    cond acc if acc {
      var p : Pos = positionAtOffset(center, ofs)
      acc = withinRoomBounds(m, p)
    } else {}
  }
  return acc
}

def findFreeRoomCoordinates(m : RoomMap) : [Coordinate] {
  var blocks : [Coordinate] = []
  loop blocks for row in range(0, m.rows) {
    loop blocks for col in range(0, m.cols) {
      cond blocks if not(m.data[row][col]) {
        blocks = push(blocks, {row = row, col = col})
      } else {}
    }
  }
  return blocks
}

def absInt(x : Int) : Int {
  cond x if ltInt(x, 0) {
    x = negInt(x)
  } else {}
  return x
}

// Computes the sigma (of a normal distribution) based on the relative
// timestamp. We use this under the assumption that an observation made closer
// in time to 0 (the logically local time) should be considered more accurate.
// If the timestamp is too close to the logically local time, we use a
// pre-determined constant instead.
def timeRelativeSigma(ts : Int) : Float {
  var min : Float = 0.01
  var x : Float = intToFloat(absInt(ts)) / intToFloat(1s)
  cond x if x < min {
    x = min
  } else { }
  return x
}

def maxDistFloatTsv(tsvs : [TSV(Dist(Float))]) : TSV(Dist(Float)) {
  var acc : TSV(Dist(Float)) = tsvs[0]
  loop acc for i in range(1, |tsvs|) {
    cond acc if gtInt(timestamp(tsvs[i]), timestamp(acc)) {
      acc = tsvs[i]
    } else {}
  }
  return acc
}

// Converts a given relative timestamp, in nanoseconds, to a number in seconds.
def timestampToSeconds(ts : Int) : Float {
  return intToFloat(ts) / intToFloat(1s)
}

// Estimate the current speed of the car through the given observed speeds,
// using Bayesian linear regression. The current implementation does not make
// use of our prior knowledge of the speed.
model speedModel(speedObs : [TSV(Float)]) : Float {
  assume m ~ Gaussian(0.0, maxAcceleration)
  assume b ~ Uniform(0.0, maxSpeed)
  assume sigma ~ Gamma(1.0, 1.0)
  // NOTE(larshum, 2023-05-15): We use Bayesian linear regression to estimate
  // the solution to the function f(t) = m * t + b, where t is the timestamp in
  // seconds. We use our prior estimation as our initial value.
  loop for tsv in speedObs {
    var ts = timestampToSeconds(timestamp(tsv))
    var rpm = value(tsv)
    var mps = rpm * wheelCircumference / 60.0
    observe mps ~ Gaussian(m * ts + b, sigma)
  }
  // NOTE(larshum, 2023-05-15): We seek the value of the function f(t) at t = 0
  // (the logically local time).
  return b
}

template speedEst(period : Int) {
  input lspeed : Float
  input rspeed : Float
  output speed : Dist(Float)
  loop {
    sdelay period
    read lspeed to lObs
    read rspeed to rObs
    var obs = concat(lObs, rObs)
    cond if gtInt(|obs|, 0) {
      infer d <- speedModel(obs) particles 1000
      write d to speed
    } else {}
  }
}

def absmax(s : [TSV(Float)]) : Float {
  var acc = 0.0
  loop acc for x in s {
    var v = value(x)
    cond acc if 0.0-v > acc || v > acc {
      acc = v
    } else {}
  }
  return acc
}

def maxDistFloatTimestamp(tsvs : [TSV(Dist(Float))]) : TSV(Dist(Float)) {
  var acc = tsvs[0]
  loop acc for tsv in tsvs {
    cond acc if ltInt(timestamp(acc), timestamp(tsv)) {
      acc = tsv
    } else {}
  }
  return acc
}

def cmpFloatTimestamp(l : TSV(Float), r : TSV(Float)) : Int {
  var acc = 0
  cond acc if gtInt(timestamp(l), timestamp(r)) {
    acc = 1
  } else {
    cond acc if ltInt(timestamp(l), timestamp(r)) {
      acc = negInt(1)
    } else {}
  }
  return acc
}

def maxFloatTimestamp(tsvs : [TSV(Float)]) : TSV(Float) {
  var acc = tsvs[0]
  loop acc for tsv in tsvs {
    cond acc if ltInt(cmpFloatTimestamp(acc, tsv), 0) {
      acc = tsv
    } else {}
  }
  return acc
}

def cmpFloat(l : Float, r : Float) : Int {
  var acc = 0
  cond acc if l > r {
    acc = 1
  } else {
    cond acc if l < r {
      acc = negInt(1)
    } else {}
  }
  return acc
}

def medianOfLastThreeFloatTsv(tsvs : [TSV(Float)]) : Float {
  var n = |tsvs|
  var a = value(tsvs[subInt(n, 3)])
  var b = value(tsvs[subInt(n, 2)])
  var c = value(tsvs[subInt(n, 1)])
  var res = 0.0
  cond res if a < b {
    cond res if b < c {
      res = b
    } else {
      res = c
    }
  } else {
    cond res if a < c {
      res = a
    } else {
      res = c
    }
  }
  return res
}

def allOutOfRange(distanceObs : [TSV(Float)], maxRange : Float) : Bool {
  var acc = true
  loop acc for tsv in distanceObs {
    cond acc if value(tsv) < maxRange {
      acc = false
    } else {}
  }
  return acc
}

model frontRearDistanceModel(distanceObs : [TSV(Float)],
                             steeringAngleObs : [TSV(Float)],
                             speedEst : TSV(Dist(Float)), maxDistance : Float,
                             maxSensorRange : Float) : Float {
  // NOTE(larshum, 2023-05-16): If all distance observations are outside of the
  // range, the true distance can be anywhere beyond the maximum range of the
  // sensor.
  var res = 0.0
  cond res if allOutOfRange(distanceObs, maxSensorRange) {
    assume res ~ Uniform(maxSensorRange, maxDistance)
  } else {
    assume v ~ value(speedEst)
    assume m ~ Gaussian(0.0, v)
    assume b ~ Uniform(0.0, maxDistance)
    assume sigma ~ Gamma(1.0, 1.0)
    cond res if absmax(steeringAngleObs) == 0.0 {
      loop for tsv in distanceObs {
        var ts = timestampToSeconds(timestamp(tsv))
        observe value(tsv) ~ Gaussian(m * ts + b, sigma)
      }
      res = b
    } else {
      res = medianOfLastThreeFloatTsv(distanceObs)
    }
  }

  return res
}

template frontRearDistance(period : Int) {
  input distObs : Float
  input steeringAngleObs : Float
  input speedEst : Dist(Float)
  output distEst : Dist(Float)
  var maxDistance = 10.0
  var acc = {
    speed = tsv(0, Uniform(0.0, maxSpeed)),
    d = Uniform(0.0, maxDistance)
  }
  loop acc {
    sdelay period
    read distObs to obs
    read steeringAngleObs to saObs
    read speedEst to speed
    cond acc if gtInt(|speed|, 0) {
      acc.speed = maxDistFloatTimestamp(speed)
    } else {}
    cond acc if absmax(saObs) == 0.0 || geqInt(|obs|, 3) {
      var obs = sort(cmpFloatTimestamp, obs)
      infer d <- frontRearDistanceModel(obs, saObs, acc.speed, maxDistance, usMaxRange)
        particles 1000
      acc.d = d
    } else {}
    write acc.d to distEst
  }
}

model sideDistanceModel(distObs : [TSV(Float)], maxSensorRange : Float,
                        maxDistance : Float) : Float {
  var res = 0.0
  cond res if allOutOfRange(distObs, maxSensorRange) {
    assume res ~ Uniform(maxSensorRange, maxDistance)
  } else {
    res = medianOfLastThreeFloatTsv(distObs)
  }
  return res
}

template sideDistance(period : Int) {
  input distObs : Float
  output distEst : Dist(Float)
  var maxDistance = 10.0
  var d = Uniform(0.0, maxDistance)
  loop {
    sdelay period
    read distObs to obs
    cond if geqInt(|obs|, 3) {
      var obs = sort(cmpFloatTimestamp, obs)
      infer d <- sideDistanceModel(obs, tofMaxRange, maxDistance) particles 1000
      write d to distEst
    } else {}
  }
}

// We choose the initial position by choosing a random block of the map,
// and then sampling coordinates within the block. We assume that the initial
// direction of the car relative to the map is known, and that the car is
// stationary when the model starts running.
model initialPositionModel(blocks : [Coordinate]) : Pos {
  var c : Coordinate = randElemExn(blocks)
  var x : Float = intToFloat(c.col) * roomBlockWidth
  var y : Float = intToFloat(c.row) * roomBlockWidth
  assume xOfs ~ Uniform(0.0, roomBlockWidth)
  assume yOfs ~ Uniform(0.0, roomBlockWidth)
  assume d ~ Uniform(0.0, 2.0 * pi)
  return { x = x + xOfs, y = y + yOfs, direction = d }
}

// The position denotes our belief of the center of the car.
def estimateDistance(ofs : Offset, p : Pos, inBounds : Pos -> Bool) : Float {
  var eps : Float = 0.05
  p = positionAtOffset(p, ofs)
  var acc : {d : Float, p : Pos} = {d = 0.0, p = p}
  loop acc while inBounds(acc.p) {
    var p : Pos = acc.p
    p.x = p.x + eps * cos(p.direction)
    p.y = p.y + eps * sin(p.direction)
    acc.d = acc.d + eps
    acc.p = p
  }
  return acc.d
}

model observeSensor(m : RoomMap, pos : Pos, s : SensorData) : Unit {
  var inBounds : Pos -> Bool = withinRoomBounds(m)
  var expectedDist : Float = estimateDistance(s.ofs, pos, inBounds)
  loop for tsv in s.obs {
    var sigma : Float = timeRelativeSigma(timestamp(tsv)) / 10.0
    assume estDist ~ value(tsv)
    cond if estDist < s.maxRange {
      observe estDist ~ Gaussian(expectedDist, sigma)
    } else {}
  }
}

model positionModel(m : RoomMap, prior : Dist(Pos), flEst : [TSV(Dist(Float))],
                    frEst : [TSV(Dist(Float))], rlEst : [TSV(Dist(Float))],
                    rrEst : [TSV(Dist(Float))], lEst : [TSV(Dist(Float))],
                    rEst : [TSV(Dist(Float))], speedEst : TSV(Dist(Float)),
                    saObs : [TSV(Float)]) : Pos {

  assume posPrev ~ prior
  assume v ~ value(speedEst)
  assume mx ~ Gaussian(0.0, 1.0)
  assume bx ~ Gaussian(posPrev.x, v)
  assume sigmax ~ Gamma(1.0, 1.0)
  assume my ~ Gaussian(0.0, 1.0)
  assume by ~ Gaussian(posPrev.y, v)
  assume sigmay ~ Gamma(1.0, 1.0)
  assume md ~ Gaussian(0.0, 1.0)
  assume bd ~ Gaussian(posPrev.direction, pi / 8.0)
  assume sigmad ~ Gamma(1.0, 1.0)

  var sensorData : [SensorData] = [
    { ofs = frontLeftOffset, obs = flEst, maxRange = usMaxRange },
    { ofs = frontRightOffset, obs = frEst, maxRange = usMaxRange },
    { ofs = rearLeftOffset, obs = rlEst, maxRange = usMaxRange },
    { ofs = rearRightOffset, obs = rrEst, maxRange = usMaxRange },
    { ofs = sideLeftOffset, obs = lEst, maxRange = tofMaxRange },
    { ofs = sideRightOffset, obs = rEst, maxRange = tofMaxRange }
  ]
  loop for s in sensorData {
    var inBounds : Pos -> Bool = withinRoomBounds(m)
    loop for tsv in s.obs {
      var t = timestampToSeconds(timestamp(tsv))
      var pos = {x = mx * t + bx, y = my * t + by, direction = md * t + bd}
      var expectedDist = estimateDistance(s.ofs, pos, inBounds)
      assume estDist ~ value(tsv)
      cond if estDist < s.maxRange {
        observe estDist ~ Gaussian(expectedDist, 0.01)
      } else {}
    }
  }
  // NOTE(larshum, 2023-05-16): Return the position at t=0.
  return { x = bx, y = by, direction = bd }
}

template positionEstimate(period : Int) {
  input frontLeft : Dist(Float)
  input frontRight : Dist(Float)
  input rearLeft : Dist(Float)
  input rearRight : Dist(Float)
  input left : Dist(Float)
  input right : Dist(Float)
  input speed : Dist(Float)
  input steeringAngle : Float
  output posEst : Dist(Pos)
  var posBudget : Int = subInt(period, 100ms)
  var m : RoomMap = readRoomMap()
  var blocks : [Coordinate] = findFreeRoomCoordinates(m)
  infer d <- initialPositionModel(blocks) particles 1000
  var acc = {
    d = d,
    speed = tsv(0, Uniform(0.0, maxSpeed))
  }
  loop acc {
    write acc.d to posEst
    sdelay period
    read frontLeft to flEst
    read frontRight to frEst
    read rearLeft to rlEst
    read rearRight to rrEst
    read left to lEst
    read right to rEst
    read speed to speedEst
    read steeringAngle to saObs
    cond acc if gtInt(|speedEst|, 0) {
      acc.speed = maxDistFloatTsv(speedEst)
    } else {}
    infer d <- positionModel(m, acc.d, flEst, frEst, rlEst, rrEst, lEst, rEst, acc.speed, saObs)
      budget posBudget
    acc.d = d
  }
}

def clamp(v : Float, lo : Float, hi : Float) : Float {
  cond v if v < lo {
    v = lo
  } else {
    cond v if v > hi {
      v = hi
    } else {}
  }
  return v
}

// Estimate the time at which the car needs to start braking in order to
// prevent a crash.
model brakeModel(m : RoomMap, posEst : TSV(Dist(Pos)),
                 speedEst : [TSV(Dist(Float))]) : Float {
  assume posPrev ~ value(posEst)

  // Estimate the speed of the car at the previous position. If we have any
  // speed estimations, we use the most recent one as our basis, and otherwise
  // we choose a random speed.
  cond v if gtInt(|speedEst|, 0) {
    var speed : TSV(Dist(Float)) = maxDistFloatTsv(speedEst)
    assume vEst ~ value(speed)
    var ts : Int = subInt(timestamp(speed), timestamp(posEst))
    assume v ~ Gaussian(vEst, timeRelativeSigma(ts) / 10.0)
  } else {
    assume v ~ Uniform(0.0, maxSpeed)
  }
  // NOTE(larshum, 2023-05-14): We clamp the speed to ensure we get a
  // value in the valid range. Further, we use a value slightly larger than
  // zero to avoid an infinite time until the crash.
  v = clamp(v, 0.01, maxSpeed)

  // TODO(larshum, 2023-05-12): This is an estimate based on how the car
  // behaves in the simulator. This should be tuned based on the behavior on
  // the car.
  var brakeDistance : Float = 5.0 * v * v

  // Assuming v is the average speed of the car, estimate for how long the car
  // can drive until it crashes into a wall (in nanoseconds) from the previous
  // position. We use this to estimate the time at which we need to start
  // braking.
  var inBounds : Pos -> Bool = carWithinRoomBounds(m)
  var crashDist : Float = estimateDistance(zeroOffset, posPrev, inBounds)
  return intToFloat(1s) * (crashDist - brakeDistance) / v
}

def cmpFloat(l : Float, r : Float) : Int {
  var res : Int = 0
  cond res if l > r {
    res = 1
  } else {
    cond res if l < r {
      res = negInt(1)
    } else {}
  }
  return res
}

def medianValue(x : {s : [Float], w : [Float]}) : Float {
  var s : [Float] = []
  var xs : [Float] = x.s
  loop s for i in range(0, |xs|) {
    s = push(s, xs[i])
  }
  s = sort(cmpFloat, s)
  return s[divInt(|s|, 2)]
}

def maxDistPosTsv(tsvs : [TSV(Dist(Pos))]) : TSV(Dist(Pos)) {
  var acc : TSV(Dist(Pos)) = tsvs[0]
  loop acc for i in range(1, |tsvs|) {
    cond acc if gtInt(timestamp(tsvs[i]), timestamp(acc)) {
      acc = tsvs[i]
    } else {}
  }
  return acc
}

template brakeEstimate(period : Int, safetyMargin : Int) {
  input pos : Dist(Pos)
  input speed : Dist(Float)
  output brake : Float
  var m : RoomMap = readRoomMap ()
  // NOTE(larshum, 2023-05-15): We assume the car is initially stationary. The
  // first position estimations will have a lot of uncertainty, so we assume it
  // takes a few seconds until the car has to start braking.
  sdelay 5s
  var nanosUntilBrake : Float = 1.0 / 0.0
  loop nanosUntilBrake {
    read pos to posEst
    read speed to speedEst
    cond nanosUntilBrake if gtInt(|posEst|, 0) {
      var posDist : TSV(Dist(Pos)) = maxDistPosTsv(posEst)
      infer d <- brakeModel(m, posDist, speedEst) particles 1000
      nanosUntilBrake = medianValue(samples d) + intToFloat(timestamp(posDist))
    } else {}
    nanosUntilBrake = nanosUntilBrake - intToFloat(period)
    cond nanosUntilBrake if nanosUntilBrake < intToFloat(safetyMargin) {
      //write 0.0 to brake
    } else {}
    sdelay period
  }
}

network {
  // Distance sensors
  sensor frontLeft : Float
  sensor frontRight : Float
  sensor rearLeft : Float
  sensor rearRight : Float
  sensor sideLeft : Float
  sensor sideRight : Float

  // Wheel sensors
  sensor speedLeft : Float
  sensor speedRight : Float
  sensor steeringAngle : Float

  // Brake actuator - determines whether to brake or not (what kind of value do
  // we want to write to this?)
  actuator brake : Float

  task speedEst = speedEst(500ms)
  task frontLeft = frontRearDistance(500ms)
  task frontRight = frontRearDistance(500ms)
  task rearLeft = frontRearDistance(500ms)
  task rearRight = frontRearDistance(500ms)
  task leftSide = sideDistance(500ms)
  task rightSide = sideDistance(500ms)
  task pos = positionEstimate(1s)
  task brake = brakeEstimate(500ms, 1500ms)

  // Speed estimation inputs
  speedLeft -> speedEst.lspeed
  speedRight -> speedEst.rspeed

  // Distance estimation inputs
  frontLeft -> frontLeft.distObs
  steeringAngle -> frontLeft.steeringAngleObs
  speedEst.speed -> frontLeft.speedEst

  frontRight -> frontRight.distObs
  steeringAngle -> frontRight.steeringAngleObs
  speedEst.speed -> frontRight.speedEst

  rearLeft -> rearLeft.distObs
  steeringAngle -> rearLeft.steeringAngleObs
  speedEst.speed -> rearLeft.speedEst

  rearRight -> rearRight.distObs
  steeringAngle -> rearRight.steeringAngleObs
  speedEst.speed -> rearRight.speedEst

  sideLeft -> leftSide.distObs

  sideRight -> rightSide.distObs

  // Position estimation inputs
  frontLeft.distEst -> pos.frontLeft
  frontRight.distEst -> pos.frontRight
  rearLeft.distEst -> pos.rearLeft
  rearRight.distEst -> pos.rearRight
  leftSide.distEst -> pos.left
  rightSide.distEst -> pos.right
  speedEst.speed -> pos.speed
  steeringAngle -> pos.steeringAngle

  // Brake estimation inputs
  speedEst.speed -> brake.speed
  pos.posEst -> brake.pos

  brake.brake -> brake
}
