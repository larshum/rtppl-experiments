type RoomMap = {
  data : [[Bool]], rows : Int, cols : Int
}

type Coordinate = { row : Int, col : Int }

type Pos = { x : Float, y : Float, direction : Float }

type Offset = { angle : Float, distance : Float, direction : Float }

type SensorData = { ofs : Offset, obs : [TSV(Dist(Float))], maxRange : Float }

type Line = { slope : Float, intercept : Float }

const pi : Float = 4.0 * atan(1.0)
const roomBlockWidth : Float = 0.1
const wheelCircumference : Float = 0.33
const maxSpeed : Float = 0.63
const usMaxRange : Float = 4.0
const usMaxAngle : Float = 0.4363323129985824
const tofMaxRange : Float = 1.25
const tofMaxAngle : Float = 0.2617993877991494
const maxDistance : Float = 10.0
const maxSteer : Float = 0.349
const wheelbase : Float = 0.35

const zeroOffset : Offset = { angle = 0.0, distance = 0.0, direction = 0.0 }
const frontLeftOffset : Offset = {
  angle = 0.0-0.209639845874, distance = 0.240260275535, direction = 0.0
}
const frontRightOffset : Offset = {
  angle = 0.209639845874, distance = 0.240260275535, direction = 0.0
}
const rearLeftOffset : Offset = {
  angle = 0.0-2.76725903758, distance = 0.30083217913, direction = pi
}
const rearRightOffset : Offset = {
  angle = 2.76725903758, distance = 0.30083217913, direction = pi
}
const sideLeftOffset : Offset = {
  angle = 0.0-2.15879893034, distance = 0.126194294641, direction = 1.5 * pi
}
const sideRightOffset : Offset = {
  angle = 2.15879893034, distance = 0.126194294641, direction = pi / 2.0
}
const sensorOffsets : [Offset] = [
  frontLeftOffset, frontRightOffset, rearLeftOffset, rearRightOffset,
  sideLeftOffset, sideRightOffset
]

const inf : Float = 0.0 / 1.0
const neginf : Float = 0.0 - inf

def tan(x : Float) : Float {
  return sin(x) / cos(x)
}

def degToRad(degAngle : Float) : Float {
  return degAngle * pi / 180.0
}

def abs(x : Float) : Float {
  cond x if x < 0.0 {
    x = 0.0 - x
  } else {}
  return x
}

def maxFloat(a : Float, b : Float) : Float {
  cond res if a < b {
    res = b
  } else {
    res = a
  }
  return res
}

def sgn(x : Float) : Float {
  cond x if x < 0.0 {
    x = 0.0 - 1.0
  } else {
    cond x if x > 0.0 {
      x = 1.0
    } else {}
  }
  return x
}

def readRoomMap() : RoomMap {
  var data : [[Bool]] = readRoomMapRuntimeHelper()
  return {data = data, rows = |data|, cols = |data[0]|}
}

def posToCoordinate(p : Pos) : Coordinate {
  return {
    row = floorToInt(p.y / roomBlockWidth),
    col = floorToInt(p.x / roomBlockWidth)
  }
}

def positionAtOffset(p : Pos, ofs : Offset) : Pos {
  p.x = p.x + ofs.distance * cos(p.direction + ofs.angle)
  p.y = p.y + ofs.distance * sin(p.direction + ofs.angle)
  p.direction = p.direction + ofs.direction
  return p
}

def withinRoomBounds(m : RoomMap, p : Pos) : Bool {
  var c : Coordinate = posToCoordinate(p)
  var res : Bool = true
  cond res if ltInt(c.row, 0) || geqInt(c.row, m.rows) || ltInt(c.col, 0) || geqInt(c.col, m.cols) {
    res = false
  } else {
    res = not(m.data[c.row][c.col])
  }
  return res
}

// Computes whether a car centered at the given position is within the bounds
// of the provided map. We estimate this by verifying that the sensors in each
// direction are within the bounds of the map.
def carWithinRoomBounds(m : RoomMap, center : Pos) : Bool {
  var sensorOffsets : [Offset] = [
    frontLeftOffset, frontRightOffset, rearLeftOffset, rearRightOffset,
    sideLeftOffset, sideRightOffset
  ]
  var acc : Bool = true
  loop acc for ofs in sensorOffsets {
    cond acc if acc {
      var p : Pos = positionAtOffset(center, ofs)
      acc = withinRoomBounds(m, p)
    } else {}
  }
  return acc
}

def findFreeRoomCoordinates(m : RoomMap) : [Coordinate] {
  var blocks : [Coordinate] = []
  loop blocks for row in range(0, m.rows) {
    loop blocks for col in range(0, m.cols) {
      cond blocks if not(m.data[row][col]) {
        blocks = push(blocks, {row = row, col = col})
      } else {}
    }
  }
  return blocks
}

// Converts a given relative timestamp, in nanoseconds, to a number in seconds.
def timestampToSeconds(ts : Int) : Float {
  return intToFloat(ts) / intToFloat(1s)
}

def cmpFloatTimestamp(l : TSV(Float), r : TSV(Float)) : Int {
  var acc = 0
  cond acc if gtInt(timestamp(l), timestamp(r)) {
    acc = 1
  } else {
    cond acc if ltInt(timestamp(l), timestamp(r)) {
      acc = negInt(1)
    } else {}
  }
  return acc
}

def maxFloatTimestamp(tsvs : [TSV(Float)]) : TSV(Float) {
  var acc = tsvs[0]
  loop acc for tsv in tsvs {
    cond acc if ltInt(cmpFloatTimestamp(acc, tsv), 0) {
      acc = tsv
    } else {}
  }
  return acc
}

model initSpeedModel() : Line {
  sample b ~ Uniform(0.0 - 0.1, 0.1)
  sample m ~ Uniform(0.0, maxSpeed)
  return {slope = b, intercept = m}
}

def carIsStationary(tsvs : [TSV(Float)]) : Bool {
  var stationary = true
  loop stationary for tsv in tsvs {
    cond stationary if value(tsv) != 0.0 {
      stationary = false
    } else {}
  }
  return stationary
}

def carAtMaxSpeed(tsvs : [TSV(Float)]) : Bool {
  var maxSpeed = false
  loop maxSpeed for tsv in tsvs {
    cond maxSpeed if value(tsv) == 0.0 {
      maxSpeed = false
    } else {}
  }
  return maxSpeed
}

// NOTE(larshum, 2023-06-12): The speed model uses three distinct states to
// describe the speed of the car. We make this simplification as the physical
// car reaches it maximum speed in such a short amount of time that it is not
// interesting to estimate exactly what its speed is in-between acceleration or
// deceleration.
model speedModel2(tsvs : [TSV(Float)]) : Float {
  var v = 0.0
  cond v if carIsStationary(tsvs) {
    // NOTE(larshum, 2023-06-12): As the lowest non-zero speed we can observe
    // is 10 RPM, we know the true speed of the car is anywhere within this
    // interval.
    // TODO: Unless we know the speed observations are very accurate, we should
    // not use a uniform distribution here (what if we're driving at 10.01
    // RPM?).
    sample v ~ Uniform(0.0, wheelCircumference / 6.0)
  } else {
    cond v if carAtMaxSpeed(tsvs) {
      // TODO: use measurement data to decide on how much "noise" to add
    } else {
      // TODO: We could be smarter here, by considering the observed values and
      // seeing whether they are strictly increasing/decreasing. Then, we could
      // detect at an earlier point in time whether the car is decelerating
      // (now we notice this when its speed is close to zero).
      var lastTsv = maxFloatTimestamp(tsvs)
      cond v if value(lastTsv) == 0.0 {
        sample v ~ Uniform(0.0, wheelCircumference / 6.0)
      } else {
        // TODO: in this case, we may not have reached the maximum speed yet.
        // Therefore, we should introduce uncertainty around a reasonable
        // estimate of the current speed. We could base this on how long time
        // has passed since we last observed a zero, as an estimate of how long
        // we have been accelerating.
      }
    }
  }
  return v
}

model speedModel(prior : TSV(Dist(Line)), tsvs : [TSV(Float)]) : Line {
  sample l ~ value(prior)
  sample sigma ~ Gamma(1.0, 1.0)

  // NOTE(larshum, 2023-06-08): We compute the new line based on the prior. We
  // are uncertain about the new acceleration (slope), but we compute the new
  // speed directly using the prior line estimation.
  sample b ~ Gaussian(l.slope, 0.1)
  var m = l.intercept + timestampToSeconds(negInt(timestamp(prior))) * l.slope

  loop for obs in tsvs {
    var ms = value(obs) * wheelCircumference / 60.0
    var t = timestampToSeconds(subInt(timestamp(obs), timestamp(prior)))
    observe ms ~ Gaussian(m + b * t, sigma)
  }

  // NOTE(larshum, 2023-06-08): We resample after making our observations, to
  // make it more likely we use the speed estimates with a high likelihood for
  // our next estimation.
  resample

  return {slope = b, intercept = m}
}

def takeNMostRecent(a : [TSV(Float)], n : Int) : [TSV(Float)] {
  a = sort(cmpFloatTimestamp, a)
  cond a if gtInt(|a|, n) {
    var res = []
    loop res for i in range(0, n) {
      res = push(res, a[subInt(|a|, subInt(n, i))])
    }
    a = res
  } else {}
  return a
}

template speedEst(period : Int) {
  input lspeed : Float
  input rspeed : Float
  output speed : Dist(Line)
  infer initSpeedModel() particles 1000 to initSpeed
  var acc = {
    prior = tsv(0, initSpeed),
    obs = []
  }
  loop acc {
    sdelay period
    read lspeed to lObs
    read rspeed to rObs
    acc.obs = takeNMostRecent(concat(acc.obs, concat(lObs, rObs)), 10)
    infer speedModel(acc.prior, acc.obs) particles 1000 to d
    write d to speed
    acc.prior = tsv(0, d)
  }
}

def clamp(value : Float, lo : Float, hi : Float) : Float {
  cond value if value < lo {
    value = lo
  } else {
    cond value if value > hi {
      value = hi
    } else {}
  }
  return value
}

def speedFunc(speedLine : Line, relativeTs : Int, ts : Int) : Float {
  var t = timestampToSeconds(subInt(ts, relativeTs))
  return clamp(speedLine.intercept + t * speedLine.slope, 0.0, maxSpeed)
}

def maxValue(s : [TSV(Float)]) : Float {
  var acc = neginf
  loop acc for x in s {
    var v = value(x)
    cond acc if v > acc {
      acc = v
    } else {}
  }
  return acc
}

def minValue(s : [TSV(Float)]) : Float {
  var acc = inf
  loop acc for x in s {
    var v = value(x)
    cond acc if v < acc {
      acc = v
    } else {}
  }
  return acc
}

def maxDistPosTimestamp(acc : TSV(Dist(Pos)), tsvs : [TSV(Dist(Pos))]) : TSV(Dist(Pos)) {
  loop acc for tsv in tsvs {
    cond acc if ltInt(timestamp(acc), timestamp(tsv)) {
      acc = tsv
    } else {}
  }
  return acc
}

def cmpFloat(l : Float, r : Float) : Int {
  var acc = 0
  cond acc if l > r {
    acc = 1
  } else {
    cond acc if l < r {
      acc = negInt(1)
    } else {}
  }
  return acc
}

def medianOfLastThreeFloatTsv(tsvs : [TSV(Float)]) : Float {
  var n = |tsvs|
  var a = value(tsvs[subInt(n, 3)])
  var b = value(tsvs[subInt(n, 2)])
  var c = value(tsvs[subInt(n, 1)])
  var res = 0.0
  cond res if a < b {
    cond res if b < c {
      res = b
    } else {
      res = c
    }
  } else {
    cond res if a < c {
      res = a
    } else {
      res = c
    }
  }
  return res
}

def allOutOfRange(distanceObs : [TSV(Float)], maxRange : Float) : Bool {
  var acc = true
  loop acc for tsv in distanceObs {
    cond acc if value(tsv) < maxRange {
      acc = false
    } else {}
  }
  return acc
}

model frontRearDistanceModel(distanceObs : [TSV(Float)],
                             saObs : [TSV(Float)], speedEst : TSV(Dist(Line)),
                             maxSensorRange : Float, dir : Float) : Float {
  // NOTE(larshum, 2023-05-16): If all distance observations are outside of the
  // range, the true distance can be anywhere beyond the maximum range of the
  // sensor.
  var res = 0.0
  cond res if allOutOfRange(distanceObs, maxSensorRange) {
    res = maxSensorRange
  } else {
    cond res if minValue(saObs) == 0.0 && maxValue(saObs) == 0.0 {
      sample l ~ value(speedEst)
      var v = speedFunc(l, timestamp(speedEst), 0)
      sample m ~ Gaussian(dir * v, 0.1)
      sample b ~ Uniform(0.0, maxDistance)
      sample sigma ~ Gamma(1.0, 1.0)
      loop for tsv in distanceObs {
        var ts = timestampToSeconds(timestamp(tsv))
        observe value(tsv) ~ Gaussian(m * ts + b, sigma)
      }
      res = b
    } else {
      res = medianOfLastThreeFloatTsv(distanceObs)
    }
  }

  return res
}

def maxDistLineTimestamp(acc : TSV(Dist(Line)), tsvs : [TSV(Dist(Line))]) : TSV(Dist(Line)) {
  loop acc for tsv in tsvs {
    cond acc if ltInt(timestamp(acc), timestamp(tsv)) {
      acc = tsv
    } else {}
  }
  return acc
}

template frontRearDistance(period : Int, dir : Float) {
  input distObs : Float
  input steeringAngleObs : Float
  input speedEst : Dist(Line)
  output distEst : Dist(Float)
  infer initSpeedModel() particles 1000 to initSpeed
  var acc = {
    lastSpeed = tsv(0, initSpeed),
    lastObs = []
  }
  loop acc {
    sdelay period
    read distObs to obs
    read steeringAngleObs to saObs
    read speedEst to speed
    acc.lastObs = takeNMostRecent(concat(acc.lastObs, obs), 10)
    acc.lastSpeed = maxDistLineTimestamp(acc.lastSpeed, speed)
    cond if geqInt(|acc.lastObs|, 3) {
      infer frontRearDistanceModel(acc.lastObs, saObs, acc.lastSpeed, usMaxRange, dir)
        particles 1000
        to d
      write d to distEst
    } else {}
  }
}

model sideDistanceModel(distObs : [TSV(Float)], maxSensorRange : Float) : Float {
  cond res if allOutOfRange(distObs, maxSensorRange) {
    res = maxSensorRange
  } else {
    res = medianOfLastThreeFloatTsv(distObs)
  }
  return res
}

template sideDistance(period : Int) {
  input distObs : Float
  output distEst : Dist(Float)
  var lastObs = []
  loop lastObs {
    sdelay period
    read distObs to obs
    cond lastObs if gtInt(|obs|, 0) {
      lastObs = takeNMostRecent(concat(lastObs, obs), 3)
    } else {}
    cond if geqInt(|lastObs|, 3) {
      infer sideDistanceModel(lastObs, tofMaxRange) particles 1000 to d
      write d to distEst
    } else {}
  }
}

// We choose the initial position by choosing a random block of the map,
// and then sampling coordinates within the block. We assume that the initial
// direction of the car relative to the map is known, and that the car is
// stationary when the model starts running.
model initialPositionModel(blocks : [Coordinate]) : Pos {
  //var c : Coordinate = randElemExn(blocks)
  //var x : Float = intToFloat(c.col) * roomBlockWidth
  //var y : Float = intToFloat(c.row) * roomBlockWidth
  //assume xOfs ~ Uniform(0.0, roomBlockWidth)
  //assume yOfs ~ Uniform(0.0, roomBlockWidth)
  //assume d ~ Uniform(0.0, 2.0 * pi)
  //return { x = x + xOfs, y = y + yOfs, direction = d }
  return {x = 3.59, y = 3.48, direction = 1.5*pi}
}

// The position denotes our belief of the center of the car. The cone angle
// represents the cone in which we observe distances - we shoot three
// particles, one from each side of the cone plus the a beam from the center.
// The first of these to collide determines our estimated distance.
def estimateDistance(ofs : Offset, coneAngle : Float, p : Pos,
                     inBounds : Pos -> Bool) : Float {
  var eps = 0.1
  p1 = positionAtOffset(p, ofs)
  p2 = p1
  p3 = p1
  p2.direction = p1.direction + coneAngle
  p3.direction = p1.direction - coneAngle
  var acc = {d = 0.0, p1 = p1, p2 = p2, p3 = p3}
  loop acc while inBounds(acc.p1) && inBounds(acc.p2) && inBounds(acc.p3) {
    var p1 = acc.p1
    p1.x = p1.x + eps * cos(p1.direction)
    p1.y = p1.y + eps * sin(p1.direction)
    acc.p1 = p1
    var p2 = acc.p2
    p2.x = p2.x + eps * cos(p2.direction)
    p2.y = p2.y + eps * sin(p2.direction)
    acc.p2 = p2
    var p3 = acc.p3
    p3.x = p3.x + eps * cos(p3.direction)
    p3.y = p3.y + eps * sin(p3.direction)
    acc.p3 = p3
    acc.d = acc.d + eps
  }
  return acc.d
}

def computePos(p0 : Pos, l : Float, r : Float, steeringAngle : Float) : Pos {
  // If the current steering angle is zero, the car is driving in a straight
  // line. In this case, just update x and y based on the direction it is
  // travelling in. Otherwise, the car will drive along the arc of a circle, so
  // we estimate the position it ends up in.
  cond p1 if steeringAngle == 0.0 {
    p1 = {
      x = p0.x + l * cos(p0.direction),
      y = p0.y + l * sin(p0.direction),
      direction = p0.direction
    }
  } else {
    // If steering angle is negative, we are steering counterclockwise.
    var d = p0.direction
    cond p1 if steeringAngle < 0.0 {
      p1 = {
        x = p0.x + r * (sin(d) - sin(d - l / r)),
        y = p0.y + r * (cos(d - l / r) - cos(d)),
        direction = d - l / r
      }
    } else {
      p1 = {
        x = p0.x + r * (sin(d + l / r) - sin(d)),
        y = p0.y + r * (cos(d) - cos(d + l / r)),
        direction = d + l / r
      }
    }
  }
  return p1
}

def smallFrontAngle(m : RoomMap, p : Pos) : Bool {
  var inBounds : Pos -> Bool = withinRoomBounds(m)
  var ld = estimateDistance(frontLeftOffset, 0.0, p, inBounds)
  var rd = estimateDistance(frontRightOffset, 0.0, p, inBounds)
  return abs(ld - rd) / maxFloat(ld, rd) > 0.2
}

def smallRearAngle(m : RoomMap, p : Pos) : Bool {
  var inBounds : Pos -> Bool = withinRoomBounds(m)
  var ld = estimateDistance(rearLeftOffset, 0.0, p, inBounds)
  var rd = estimateDistance(rearRightOffset, 0.0, p, inBounds)
  return abs(ld - rd) / maxFloat(ld, rd) > 0.2
}

def areaBelowLine(f : Int -> Float, a : Int, b : Int) : Float {
  var delta = timestampToSeconds(subInt(b, a))
  return ((f(a) + f(b)) * delta) / 2.0
}

model positionModel(m : RoomMap, prior : TSV(Dist(Pos)), flEst : [TSV(Dist(Float))],
                    frEst : [TSV(Dist(Float))], rlEst : [TSV(Dist(Float))],
                    rrEst : [TSV(Dist(Float))], lEst : [TSV(Dist(Float))],
                    rEst : [TSV(Dist(Float))], speedEst : TSV(Dist(Line)),
                    saObs : TSV(Float)) : Pos {

  sample posPrev ~ value(prior)
  sample sigma ~ Gamma(0.5, 1.0)
  sample l ~ value(speedEst)
  var speedFn = speedFunc(l, timestamp(speedEst))

  // We assume the most recent steering angle is the current steering angle. We
  // compute this based on the observed behavior of the wheels when given
  // different steering inputs.
  // NOTE(larshum, 2023-05-23): We swap the sign of the steering angle because
  // the y-axis of the map is inverted (the upper left corner of the PNG is
  // (0,0)).
  cond sa if value(saObs) > 0.0 {
    sa = 0.03 - degToRad(value(saObs)) / maxSteer * 0.186
  } else {
    sa = 0.03 + degToRad(value(saObs)) / maxSteer * 0.243
  }
  var turnRadius = wheelbase / tan(sa)
  cond turnRadius if turnRadius < 0.0 {
    turnRadius = 0.0 - turnRadius
  } else {}

  // NOTE(larshum, 2023-05-25): We always consider sensor data from the sides.
  // For the front and rear sensors, we ignore the data if the estimated
  // distance between the sensors is too large, as we cannot rely on such
  // observations for the sound-based sensors.
  var sensorData : [SensorData] = [
    { ofs = sideLeftOffset, obs = lEst, maxRange = tofMaxRange, maxAngle = tofMaxAngle },
    { ofs = sideRightOffset, obs = rEst, maxRange = tofMaxRange, maxAngle = tofMaxAngle }
  ]
  cond sensorData if smallFrontAngle(m, posPrev) {
    sensorData = push(sensorData,
    { ofs = frontLeftOffset, obs = flEst, maxRange = usMaxRange, maxAngle = usMaxAngle }
    )
    sensorData = push(sensorData,
    { ofs = frontRightOffset, obs = frEst, maxRange = usMaxRange, maxAngle = usMaxAngle }
    )
  } else {}
  cond sensorData if smallRearAngle(m, posPrev) {
    sensorData = push(sensorData,
    { ofs = rearLeftOffset, obs = rlEst, maxRange = usMaxRange, maxAngle = usMaxAngle }
    )
    sensorData = push(sensorData,
    { ofs = rearRightOffset, obs = rrEst, maxRange = usMaxRange, maxAngle = usMaxAngle }
    )
  } else {}

  var inBounds : Pos -> Bool = withinRoomBounds(m)
  loop for s in sensorData {
    loop for tsv in s.obs {
      var distTravelled = areaBelowLine(speedFn, timestamp(prior), timestamp(tsv))
      var pos = computePos(posPrev, distTravelled, turnRadius, sa)
      var expectedDist = estimateDistance(s.ofs, s.maxAngle, pos, inBounds)
      cond expectedDist if expectedDist > s.maxRange {
        expectedDist = s.maxRange
      } else {}
      sample estDist ~ value(tsv)
      observe estDist ~ Gaussian(expectedDist, sigma)
    }
  }

  var dist = areaBelowLine(speedFn, timestamp(prior), 0)
  var pos = computePos(posPrev, dist, turnRadius, sa)
  cond if not(carWithinRoomBounds(m, pos)) {
    degenerate
  } else {}
  return pos
}

template positionEstimate(period : Int) {
  input frontLeft : Dist(Float)
  input frontRight : Dist(Float)
  input rearLeft : Dist(Float)
  input rearRight : Dist(Float)
  input left : Dist(Float)
  input right : Dist(Float)
  input speed : Dist(Line)
  input steeringAngle : Float
  output posEst : Dist(Pos)
  var posBudget : Int = subInt(period, 100ms)
  var m : RoomMap = readRoomMap()
  var blocks : [Coordinate] = findFreeRoomCoordinates(m)
  infer initialPositionModel(blocks) particles 1000 to d
  infer initSpeedModel() particles 1000 to initSpeed
  var acc = {
    d = tsv(0, d),
    sa = tsv(0, 0.0),
    speed = tsv(0, initSpeed)
  }
  loop acc {
    write value(acc.d) to posEst
    sdelay period
    read frontLeft to flEst
    read frontRight to frEst
    read rearLeft to rlEst
    read rearRight to rrEst
    read left to lEst
    read right to rEst
    read speed to speedEst
    read steeringAngle to saObs
    acc.sa = maxFloatTimestamp(concat([acc.sa], saObs))
    acc.speed = maxDistLineTimestamp(acc.speed, speedEst)
    infer positionModel(m, acc.d, flEst, frEst, rlEst, rrEst, lEst, rEst,
                        acc.speed, acc.sa)
      budget posBudget
      to d
    acc.d = tsv(0, d)
  }
}

def clamp(v : Float, lo : Float, hi : Float) : Float {
  cond v if v < lo {
    v = lo
  } else {
    cond v if v > hi {
      v = hi
    } else {}
  }
  return v
}

model brakeDistanceModel(m : RoomMap, pos : TSV(Dist(Pos)), speed : TSV(Dist(Line))) : Float {
  sample p ~ value(pos)

  // Estimate the current position based on our position and speed estimates.
  sample l ~ value(speed)
  var speedFn = speedFunc(l, timestamp(speed))
  var dist = areaBelowLine(speedFn, timestamp(pos), 0)
  var currPos = {
    x = p.x + dist * cos(p.direction),
    y = p.y + dist * sin(p.direction),
    direction = p.direction
  }

  // Compute the distance needed to brake if we start now.
  // TODO: tune this for the physical car.
  var brakeDist = 1.0

  // Compute the distance until the car crashes given that it keeps driving in
  // its current direction.
  var inBounds : Pos -> Bool = carWithinRoomBounds(m)
  // TODO: choose the cone angle with more care here...
  var crashDist = estimateDistance(zeroOffset, 0.25, currPos, inBounds)
  return crashDist - brakeDist
}

def medianValue(x : {s : [Float], w : [Float]}) : Float {
  var s : [Float] = []
  var xs : [Float] = x.s
  loop s for i in range(0, |xs|) {
    s = push(s, xs[i])
  }
  s = sort(cmpFloat, s)
  return s[divInt(|s|, 2)]
}

// The brake estimation determines how far ahead in terms of distance the car
// needs to brake to avoid collision. The provided safety margin determines how
// much earlier (in terms of distance) the emergency brake is activated. For
// example, if the car has to brake in 0.1m and the safety margin is 0.2m, the
// task will signal to activate the emergency brakes.
template brakeEstimate(period : Int, safetyMargin : Float) {
  input pos : Dist(Pos)
  input speed : Dist(Line)
  output brake : Float
  var m : RoomMap = readRoomMap ()
  var blocks : [Coordinate] = findFreeRoomCoordinates(m)
  infer initialPositionModel(blocks) particles 1000 to d
  infer initSpeedModel() particles 1000 to initSpeed
  var acc = {
    speed = tsv(0, initSpeed),
    pos = tsv(0, d)
  }
  // Wait a while until our first estimation, as the first position estimates
  // are highly inaccurate.
  sdelay 5s
  loop acc {
    read pos to posEst
    read speed to speedEst
    acc.pos = maxDistPosTimestamp(acc.pos, posEst)
    acc.speed = maxDistLineTimestamp(acc.speed, speedEst)
    infer brakeDistanceModel(m, acc.pos, acc.speed) particles 1000 to d
    cond if medianValue(samples d) < safetyMargin {
      write 0.0 to brake
    } else {}
    sdelay period
  }
}

system {
  // Distance sensors (payload contains distance in meters)
  sensor frontLeft : Float
  sensor frontRight : Float
  sensor rearLeft : Float
  sensor rearRight : Float
  sensor sideLeft : Float
  sensor sideRight : Float

  // Wheel sensors
  sensor speedLeft : Float // speed in RPM
  sensor speedRight : Float // speed in RPM
  sensor steeringAngle : Float // steering in degrees

  // Brake actuator
  // Writing a value to this actuator (the payload is irrelevant) starts the
  // emergency brakes, running the motor in reverse and preventing acceleration
  // inputs.
  actuator brake : Float

  // Tasks
  // We define periodic tasks, where the first argument to each task template
  // denotes the period of the respective tasks.
  task speedEst = speedEst(500ms)
  task frontLeft = frontRearDistance(500ms, 0.0 - 1.0)
  task frontRight = frontRearDistance(500ms, 0.0 - 1.0)
  task rearLeft = frontRearDistance(500ms, 1.0)
  task rearRight = frontRearDistance(500ms, 1.0)
  task leftSide = sideDistance(500ms)
  task rightSide = sideDistance(500ms)
  task pos = positionEstimate(1s)
  task brake = brakeEstimate(250ms, 0.1)

  // Speed estimation inputs
  speedLeft -> speedEst.lspeed
  speedRight -> speedEst.rspeed

  // Distance estimation inputs
  frontLeft -> frontLeft.distObs
  steeringAngle -> frontLeft.steeringAngleObs
  speedEst.speed -> frontLeft.speedEst

  frontRight -> frontRight.distObs
  steeringAngle -> frontRight.steeringAngleObs
  speedEst.speed -> frontRight.speedEst

  rearLeft -> rearLeft.distObs
  steeringAngle -> rearLeft.steeringAngleObs
  speedEst.speed -> rearLeft.speedEst

  rearRight -> rearRight.distObs
  steeringAngle -> rearRight.steeringAngleObs
  speedEst.speed -> rearRight.speedEst

  sideLeft -> leftSide.distObs

  sideRight -> rightSide.distObs

  // Position estimation inputs
  frontLeft.distEst -> pos.frontLeft
  frontRight.distEst -> pos.frontRight
  rearLeft.distEst -> pos.rearLeft
  rearRight.distEst -> pos.rearRight
  leftSide.distEst -> pos.left
  rightSide.distEst -> pos.right
  speedEst.speed -> pos.speed
  steeringAngle -> pos.steeringAngle

  // Brake estimation inputs
  speedEst.speed -> brake.speed
  pos.posEst -> brake.pos

  brake.brake -> brake
}
