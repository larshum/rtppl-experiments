type RoomMap = {
  data : [[Bool]], rows : Int, cols : Int
}

type Coordinate = {row : Int, col : Int}

type Pos = { x : Float, y : Float, direction : Float }

type Offset = { angle : Float, distance : Float, direction : Float }

type SensorData = { ofs : Offset, obs : [TSV(Dist(Float))], maxRange : Float }

const roomBlockWidth : Float = 0.1
const maxSpeed : Float = 0.5
const wheelCircumference : Float = 0.35
const ultrasonicMaxRange : Float = 4.0
const tofMaxRange : Float = 2.0

const zeroOffset : Offset = { angle = 0.0, distance = 0.0, direction = 0.0 }
const frontLeftOffset : Offset = {
  angle = 0.0-0.209639845874, distance = 0.240260275535, direction = 0.0
}
const frontRightOffset : Offset = {
  angle = 0.209639845874, distance = 0.240260275535, direction = 0.0
}
const rearLeftOffset : Offset = {
  angle = 0.0-2.76725903758, distance = 0.30083217913, direction = pi
}
const rearRightOffset : Offset = {
  angle = 2.76725903758, distance = 0.30083217913, direction = pi
}
const sideLeftOffset : Offset = {
  angle = 0.0-2.15879893034, distance = 0.126194294641, direction = (3.0 * pi) / 2.0
}
const sideRightOffset : Offset = {
  angle = 2.15879893034, distance = 0.126194294641, direction = pi / 2.0
}
const sensorOffsets : [Offset] = [
  frontLeftOffset, frontRightOffset, rearLeftOffset, rearRightOffset,
  sideLeftOffset, sideRightOffset
]

def readRoomMap() : RoomMap {
  var data : [[Bool]] = readRoomMapRuntimeHelper()
  return {data = data, rows = |data|, cols = |data[0]|}
}

def posToCoordinate(p : Pos) : Coordinate {
  return {
    row = floorToInt(p.y / roomBlockWidth),
    col = floorToInt(p.x / roomBlockWidth)
  }
}

def positionAtOffset(p : Pos, ofs : Offset) : Pos {
  p.x = p.x + ofs.distance * cos(p.direction + ofs.angle)
  p.y = p.y + ofs.distance * sin(p.direction + ofs.angle)
  p.direction = p.direction + ofs.direction
  return p
}

def withinRoomBounds(m : RoomMap, p : Pos) : Bool {
  var c : Coordinate = posToCoordinate(p)
  var res : Bool = true
  cond res if ltInt(c.row, 0) || geqInt(c.row, m.rows) || ltInt(c.col, 0) || geqInt(c.col, m.cols) {
    res = false
  } else {
    res = not(m.data[c.row][c.col])
  }
  return res
}

// Computes whether a car centered at the given position is within the bounds
// of the provided map. We estimate this by verifying that the sensors in each
// direction are within the bounds of the map.
def carWithinRoomBounds(m : RoomMap, center : Pos) : Bool {
  var sensorOffsets : [Offset] = [
    frontLeftOffset, frontRightOffset, rearLeftOffset, rearRightOffset,
    sideLeftOffset, sideRightOffset
  ]
  var acc : Bool = true
  loop acc for ofs in sensorOffsets {
    cond acc if acc {
      var p : Pos = positionAtOffset(center, ofs)
      acc = withinRoomBounds(m, p)
    } else {}
  }
  return acc
}

def findFreeRoomCoordinates(m : RoomMap) : [Coordinate] {
  var blocks : [Coordinate] = []
  loop blocks for row in range(0, m.rows) {
    loop blocks for col in range(0, m.cols) {
      cond blocks if not(m.data[row][col]) {
        blocks = push(blocks, {row = row, col = col})
      } else {}
    }
  }
  return blocks
}

def absInt(x : Int) : Int {
  cond x if ltInt(x, 0) {
    x = negInt(x)
  } else {}
  return x
}

// Computes the sigma (of a normal distribution) based on the relative
// timestamp. We use this under the assumption that an observation made closer
// in time to 0 (the logically local time) should be considered more accurate.
// If the timestamp is too close to the logically local time, we use a
// pre-determined constant instead.
def timeRelativeSigma(ts : Int) : Float {
  var min : Float = 0.01
  var x : Float = intToFloat(absInt(ts)) / intToFloat(1s)
  cond x if x < min {
    x = min
  } else { }
  return x
}

def maxDistFloatTsv(tsvs : [TSV(Dist(Float))]) : TSV(Dist(Float)) {
  var acc : TSV(Dist(Float)) = tsvs[0]
  loop acc for i in range(1, |tsvs|) {
    cond acc if gtInt(timestamp(tsvs[i]), timestamp(acc)) {
      acc = tsvs[i]
    } else {}
  }
  return acc
}

// We estimate the current speed of the car based on the observed speeds from
// the left and right wheels. Note that this model does not make use of earlier
// estimations, as the current speed of the car does not depend much on the
// speed during our previous estimation. (it might be a good idea to include
// that as well)
model speedModel(prior : Dist(Float), obs : [TSV(Float)]) : Float {
  // Start from our earlier estimation of the speed (in meters per second).
  assume vprev ~ prior

  // Our new belief of the speed is normally distributed around our old belief.
  assume v ~ Gaussian(vprev, 0.1)
  cond if v < 0.0 || v > maxSpeed {
    degenerate
  } else {
    loop for tsv in obs {
      var sigma : Float = timeRelativeSigma(timestamp(tsv)) / 10.0
      var rpm : Float = value(tsv)
      var mps : Float = rpm * wheelCircumference / 60.0
      observe mps ~ Gaussian(v, sigma)
    }
  }
  resample
  return v
}

template speedEst(period : Int) {
  input lspeed : Float
  input rspeed : Float
  output speed : Dist(Float)
  var d : Dist(Float) = Uniform(0.0, maxSpeed)
  loop d {
    sdelay period
    read lspeed to lin
    read rspeed to rin
    var obs : [TSV(Float)] = concat(lin, rin)
    infer d <- speedModel(d, obs) particles 1000
    write d to speed
  }
}

// Estimates the "true" distance between the car and an obstacle given
// observations from one or multiple sensors placed at a certain direction.
model distanceModel(period : Int, prior : Dist(Float), obs : [TSV(Float)],
                  maxSensorRange : Float) : Float {
  assume d ~ Uniform(0.0, 10.0)
  cond if eqInt(|obs|, 0) {
    // If we have no new observations, we sample from the distribution of
    // distances from our previous estimation and treat that as an observation.
    assume dprev ~ prior
    observe dprev ~ Gaussian(d, timeRelativeSigma(negInt(period)))
  } else {
    loop for tsv in obs {
      var sigma : Float = timeRelativeSigma(timestamp(tsv))
      var obsDist : Float = value(tsv)
      // We include a probability that a given observed value is noise in the
      // model, in which case we completely ignore the observed value.
      // TODO: choose this value based on real-world data and choose exact
      // behavior based on which kind of sensor we are estimating for.
      assume obsNotNoise ~ Bernoulli(0.9)
      cond if obsNotNoise {
        cond if obsDist > maxSensorRange {
          cond if not(d > maxSensorRange) { degenerate } else {}
        } else {
          observe obsDist ~ Gaussian(d, sigma)
        }
      } else {}
    }
  }
  return d
}

// Estimates the distance observed by a particular sensor. This sensor is
// assumed to be installed at the provided offset relative to the center of the
// car.
template ultrasonicDistance(period : Int) {
  input distObs : Float
  output dist : Dist(Float)
  var d : Dist(Float) = Uniform(0.0, 10.0)
  loop d {
    sdelay period
    read distObs to obs
    infer d <- distanceModel(period, d, obs, ultrasonicMaxRange) particles 1000
    write d to dist
  }
}

template tofDistance(period : Int) {
  input distObs : Float
  output dist : Dist(Float)
  var d : Dist(Float) = Uniform(0.0, 10.0)
  loop d {
    sdelay period
    read distObs to obs
    infer d <- distanceModel(period, d, obs, tofMaxRange) particles 1000
    write d to dist
  }
}

// We choose the initial position by choosing a random block of the map,
// and then sampling coordinates within the block. We assume that the initial
// direction of the car relative to the map is known, and that the car is
// stationary when the model starts running.
model initialPositionModel(blocks : [Coordinate]) : Pos {
  var c : Coordinate = randElemExn(blocks)
  var x : Float = intToFloat(c.col) * roomBlockWidth
  var y : Float = intToFloat(c.row) * roomBlockWidth
  assume xOfs ~ Uniform(0.0, roomBlockWidth)
  assume yOfs ~ Uniform(0.0, roomBlockWidth)
  assume d ~ Uniform(0.0, 2.0 * pi)
  return { x = x + xOfs, y = y + yOfs, direction = d }
}

// The position denotes our belief of the center of the car.
def estimateDistance(m : RoomMap, ofs : Offset, p : Pos, eps : Float) : Float {
  p = positionAtOffset(p, ofs)
  var acc : {d : Float, p : Pos} = {d = 0.0, p = p}
  loop acc while withinRoomBounds(m, acc.p) {
    var p : Pos = acc.p
    p.x = p.x + eps * cos(p.direction)
    p.y = p.y + eps * sin(p.direction)
    acc.d = acc.d + eps
    acc.p = p
  }
  return acc.d
}

model observeSensor(m : RoomMap, pos : Pos, s : SensorData) : Unit {
  var estDist : Float = estimateDistance(m, s.ofs, pos, 0.05)
  loop for tsv in s.obs {
    var sigma : Float = timeRelativeSigma(timestamp(tsv)) / 10.0
    assume obsDist ~ value(tsv)
    cond if obsDist < s.maxRange {
      observe obsDist ~ Gaussian(estDist, sigma)
    } else {}
  }
}

model positionModel(m : RoomMap, prior : Dist(Pos), flObs : [TSV(Dist(Float))],
                  frObs : [TSV(Dist(Float))], rlObs : [TSV(Dist(Float))],
                  rrObs : [TSV(Dist(Float))], lObs : [TSV(Dist(Float))],
                  rObs : [TSV(Dist(Float))], speedEst : [TSV(Dist(Float))]) : Pos {
  assume posPrev ~ prior

  // Use the most recent speed estimation as a basis to estimate the current
  // speed of the car. If no estimations are available, we have no knowledge of
  // the speed.
  cond v if gtInt(|speedEst|, 0) {
    var speedDist : TSV(Dist(Float)) = maxDistFloatTsv(speedEst)
    assume vprev ~ value(speedDist)
    var s : Float = timeRelativeSigma(timestamp(speedDist))
    assume v ~ Gaussian(vprev, s)
  } else {
    assume v ~ Uniform(0.0, maxSpeed)
  }
  assume d ~ Gaussian(posPrev.direction, pi / 4.0)
  var x : Float = posPrev.x + v * cos(d)
  var y : Float = posPrev.y + v * sin(d)
  var pos : Pos = {x = x, y = y, direction = d}

  cond if not(carWithinRoomBounds(m, pos)) {
    degenerate
  } else {
    var sensorData : [SensorData] = [
      { ofs = frontLeftOffset, obs = flObs, maxRange = ultrasonicMaxRange },
      { ofs = frontRightOffset, obs = frObs, maxRange = ultrasonicMaxRange },
      { ofs = rearLeftOffset, obs = rlObs, maxRange = ultrasonicMaxRange },
      { ofs = rearRightOffset, obs = rrObs, maxRange = ultrasonicMaxRange },
      { ofs = sideLeftOffset, obs = lObs, maxRange = tofMaxRange },
      { ofs = sideRightOffset, obs = rObs, maxRange = tofMaxRange }
    ]
    loop for s in sensorData {
      observeSensor(m, pos, s)
    }
  }

  return pos
}

template positionEstimate(period : Int) {
  input frontLeft : Dist(Float)
  input frontRight : Dist(Float)
  input rearLeft : Dist(Float)
  input rearRight : Dist(Float)
  input left : Dist(Float)
  input right : Dist(Float)
  input speed : Dist(Float)
  input steeringAngle : Float
  output pos : Dist(Pos)
  var posBudget : Int = subInt(period, 100ms)
  var m : RoomMap = readRoomMap()
  var blocks : [Coordinate] = findFreeRoomCoordinates(m)
  infer d <- initialPositionModel(blocks) particles 1000
  loop d {
    sdelay period
    read frontLeft to flEst
    read frontRight to frEst
    read rearLeft to rlEst
    read rearRight to rrEst
    read left to lEst
    read right to rEst
    read speed to speedEst
    infer d <- positionModel(m, d, flEst, frEst, rlEst, rrEst, lEst, rEst, speedEst)
      budget posBudget
    write d to pos
  }
}

// Estimate the time at which the car needs to start braking in order to
// prevent a crash.
model crashBrake(m : RoomMap, posEst : TSV(Dist(Pos)),
                 speedEst : [TSV(Dist(Float))]) : Float {
  assume posPrev ~ value(posEst)

  // Estimate the current speed of the car. If we have any speed estimations,
  // we use the most recent one as our basis, and otherwise we choose a random
  // speed.
  cond v if gtInt(|speedEst|, 0) {
    var speed : TSV(Dist(Float)) = maxDistFloatTsv(speedEst)
    assume vEst ~ value(speed)
    var ts : Int = subInt(timestamp(speed), timestamp(posEst))
    assume v ~ Gaussian(vEst, timeRelativeSigma(ts))
  } else {
    assume v ~ Uniform(0.0, maxSpeed)
  }
  cond if v < 0.0 {
    degenerate
  } else {}

  // Remove for easier debugging
  //assume d ~ Gaussian(posPrev.direction, pi / 16.0)
  posPrev.direction = pi

  // TODO(larshum, 2023-05-12): This is an estimate based on how the car
  // behaves in the simulator. This should be tuned based on the behavior on
  // the car.
  var brakeDistance : Float = 5.0 * v * v

  // Assuming v is the average speed of the car, estimate for how long the car
  // can drive until it crashes into a wall (in nanoseconds) from the previous
  // position. We use this to estimate the time at which we need to start
  // braking.
  var crashDist : Float = estimateDistance(m, zeroOffset, posPrev, 0.01)
  var brakeDist : Float = crashDist - brakeDistance
  return (brakeDist / v) * intToFloat(1s)
}

def cmpSample(l : {s:Float,w:Float}, r : {s:Float,w:Float}) : Int {
  cond res if l.s > r.s {
    res = 1
  } else {
    cond res if l.s < r.s {
      res = negInt(1)
    } else {
      res = 0
    }
  }
  return res
}

def expectedValue(x : {s : [Float], w : [Float]}) : Float {
  var s : [{s:Float,w:Float}] = []
  loop s for i in range(0, |x.s|) {
    cond s if exp(x.w[i]) > 0.0 {
      s = push(s, {s=x.s[i],w=x.w[i]})
    } else {}
  }
  var s : [{s:Float,w:Float}] = sort(cmpSample, s)
  var x : {s:Float,w:Float} = s[divInt(mulInt(|s|,10),100)]
  return x.s
  // var acc : Float = 0.0
  // loop acc for i in range(0, |x.s|) {
  //   acc = acc + (x.s[i]) * exp(x.w[i])
  // }
  // return acc
}

def maxDistPosTsv(tsvs : [TSV(Dist(Pos))]) : TSV(Dist(Pos)) {
  var acc : TSV(Dist(Pos)) = tsvs[0]
  loop acc for i in range(1, |tsvs|) {
    cond acc if gtInt(timestamp(tsvs[i]), timestamp(acc)) {
      acc = tsvs[i]
    } else {}
  }
  return acc
}

template brakeEstimate(period : Int, safetyMargin : Int) {
  input pos : Dist(Pos)
  input speed : Dist(Float)
  output brake : Float
  var m : RoomMap = readRoomMap ()
  loop {
    sdelay period
    read pos to posEst
    read speed to speedEst
    cond if gtInt(|posEst|, 0) {
      var posDist : TSV(Dist(Pos)) = maxDistPosTsv(posEst)
      infer d <- brakeModel(m, posDist, speedEst) particles 1000
      // NOTE(larshum, 2023-05-12): We compute the expected number of
      // nanoseconds until we crash and determine the latest point at which we
      // need to start braking based on the provided safety margin parameter.
      var nanosUntilBrake : Int =
        addInt(floorToInt(expectedValue(samples d)), timestamp(posDist))
      write 0.0 to brake offset subInt(nanosUntilBrake, safetyMargin)
    } else {}
  }
}

network {
  // Distance sensors
  sensor frontLeft : Float
  sensor frontRight : Float
  sensor rearLeft : Float
  sensor rearRight : Float
  sensor sideLeft : Float
  sensor sideRight : Float

  // Wheel sensors
  sensor speedLeft : Float
  sensor speedRight : Float
  sensor steeringAngle : Float

  // Brake actuator - determines whether to brake or not (what kind of value do
  // we want to write to this?)
  actuator brake : Float

  task speedEst = speedEst(500ms)
  task frontLeftDist = ultrasonicDistance(500ms)
  task frontRightDist = ultrasonicDistance(500ms)
  task rearLeftDist = ultrasonicDistance(500ms)
  task rearRightDist = ultrasonicDistance(500ms)
  task leftDist = tofDistance(500ms)
  task rightDist = tofDistance(500ms)
  task pos = positionEstimate(1s)
  task brake = brakeEstimate(500ms, 200ms)

  // Network specification
  speedLeft -> speedEst.lspeed
  speedRight -> speedEst.rspeed
  speedEst.speed -> pos.speed
  speedEst.speed -> brake.speed
  frontLeft -> frontLeftDist.distObs
  frontRight -> frontRightDist.distObs
  rearLeft -> rearLeftDist.distObs
  rearRight -> rearRightDist.distObs
  sideLeft -> leftDist.distObs
  sideRight -> rightDist.distObs
  frontLeftDist.dist -> pos.frontLeft
  frontRightDist.dist -> pos.frontRight
  rearLeftDist.dist -> pos.rearLeft
  rearRightDist.dist -> pos.rearRight
  leftDist.dist -> pos.left
  rightDist.dist -> pos.right
  steeringAngle -> pos.steeringAngle
  pos.pos -> brake.pos
  brake.brake -> brake
}
