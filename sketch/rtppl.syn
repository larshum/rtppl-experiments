language Rtppl

include "lexer.mc"

start Program

type Program
type Top
type Stmt
type StmtNoIdent
type Expr {grouping = "(" ")", }
type ExprNoIdent
type Type {grouping = "(" ")", }
type TypeNoIdent
type Const

type Port

type Main
type Task
type Connection
type PortSpec

token LIdent {
  repr = LIdentRepr {},
  constructor = LIdentTok,
  fragment = LIdentTokenParser,
  ty = String,
}
token UIdent {
  repr = UIdentRepr {},
  constructor = UIdentTok,
  fragment = UIdentTokenParser,
  ty = String,
}
token Integer {
  repr = IntRepr {},
  constructor = IntTok,
  fragment = UIntTokenParser,
  ty = Int,
}
token Float {
  repr = FloatRepr {},
  constructor = FloatTok,
  fragment = UFloatTokenParser,
  ty = Float,
}
token Boolean {
  repr = BoolRepr {},
  constructor = BoolTok,
  fragment = BooleanTokenParser,
  ty = Bool,
}
token StringLit {
  repr = StringRepr {},
  constructor = StringTok,
  fragment = StringTokenParser,
  ty = String,
}

token LName {
  base = LIdent,
  wrap = nameNoSym,
  ty = Name,
}
token UName {
  base = UIdent,
  wrap = nameNoSym,
  ty = Name,
}

token {fragment = OperatorTokenParser,}
token {fragment = CommaTokenParser,}
token {fragment = BracketTokenParser,}
token {fragment = WhitespaceParser,}
token {fragment = RTPPLLineCommentParser,}

prod Program : Program = tops:Top* main:Main

prod Sensor : Top = "sensor" id:LName ":" ty:Type
prod Actuator : Top = "actuator" id:LName ":" ty:Type
prod Constant : Top = "const" id:LName ":" ty:Type "=" e:Expr
prod TypeAlias : Top = "type" id:UName "=" ty:Type
prod FunctionDef : Top =
  "def" id:LName "(" (params:{id:LName ":" ty:Type} ("," params:{id:LName ":" ty:Type})*)? ")"
  ":" ty:Type "{" body:{ports:Port* stmts:Stmt*} "}"

prod Input : Port = "input" id:LIdent ":" ty:Type
prod Output : Port = "output" id:LIdent ":" ty:Type

prod Binding : Stmt = "var" id:LName ":" ty:Type "=" e:Expr
prod Condition : Stmt =
  "if" cond:Expr "{" thn:Stmt* "}" "else" "{" els:Stmt* "}"
prod ForIn : Stmt = "for" id:LName "in" e:Expr "{" body:Stmt* "}"
prod Loop : Stmt = "loop" "{" body:Stmt* "}"
prod Return : Stmt = "return" e:Expr
prod Break : Stmt = "break"

-- NOTE(larshum, 2023-03-06): Grammar workarounds to make it LL(1).
prod IdentPlusStmt : Stmt = id:LName next:StmtNoIdent
prod Reassign : StmtNoIdent = ("." proj:LIdent)? "=" e:Expr
prod FunctionCallS : StmtNoIdent = "(" (args:Expr ("," args:Expr)*)? ")"
prod IdentPlusExpr : Expr = id:LName next:ExprNoIdent
prod Variable : ExprNoIdent = empty
prod FunctionCallE : ExprNoIdent = "(" (args:Expr ("," args:Expr)*)? ")"
prod Projection : ExprNoIdent = "." id:LIdent

prod ArrayAccess : Expr = e:Expr "[" idx:Expr "]"
prod ArrayLit : Expr = "[" (elems:Expr ("," elems:Expr)*)? "]"
prod RecordLit : Expr = "{" (fields:{id:LIdent "=" e:Expr} ("," fields:{id:LIdent "=" e:Expr})*)? "}"
prod Literal : Expr = const:Const

infix Add : Expr = "+"
infix Sub : Expr = "-"
infix Mul : Expr = "*"
infix Div : Expr = "/"
infix Rem : Expr = "%"
infix Eq : Expr = "=="
infix Geq : Expr = ">="
infix Lt : Expr = "<"
infix Gt : Expr = ">"
infix And : Expr = "&&"

precedence {
  Mul Div Rem;
  Add Sub;
  Eq Geq Lt Gt;
  And;
}

prod Main : Main =
  "main" "(" (params:{id:LName ":" ty:Type} ("," params:{id:LName ":" ty:Type})*)? ")"
  "{" tasks:Task* connections:Connection* "}"

prod Task : Task = "task" id:LName "=" templateId:LName "(" (args:Expr ("," args:Expr)*)? ")"
prod Connection : Connection = from:PortSpec "->" to:PortSpec
prod PortSpec : PortSpec = port:LName ("." id:LIdent)?

prod Int : Type = "Int"
prod Float : Type = "Float"
prod Bool : Type = "Bool"
prod Unit : Type = "Unit"
prod Seq : Type = "[" ty:Type "]"
prod Record : Type =
  "{" (fields:{id:LIdent ":" ty:Type} ("," fields:{id:LIdent ":" ty:Type})*)? "}"
prod right Function : Type = from:Type "->" to:Type

-- NOTE(larshum, 2023-03-06): Yet another workaround to make grammar LL(1).
prod Alias : Type = id:UName next:TypeNoIdent
prod Direct : TypeNoIdent = empty
prod Application : TypeNoIdent = "(" args:Type ("," args:Type)* ")"

prod LitInt : Const = value:Integer
prod LitFloat : Const = value:Float
prod LitBool : Const = value:Boolean
prod LitString : Const = value:StringLit
