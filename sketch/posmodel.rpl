// Distance sensors
sensor distanceFrontLeft : Float
sensor distanceFrontRight : Float
sensor distanceRearLeft : Float
sensor distanceRearRight : Float
sensor distanceSideLeft : Float
sensor distanceSideRight : Float

// Wheel sensors
sensor wheelSpeedLeft : Float
sensor wheelSpeedRight : Float
sensor wheelSteeringAngle : Float

type DistanceInputs = {
  fl : TSV(Float), fr : TSV(Float), rl : TSV(Float),
  rr : TSV(Float), sl : TSV(Float), sr : TSV(Float)
}
type WheelInputs = {
  ls : [TSV(Float)], rs : [TSV(Float)], sa : [TSV(Float)]
}

// An actuator, which determines whether to brake or not.
actuator wheelBrake : Bool

type RoomMap = {rows : Int, cols : Int, sq : [[Bool]], sqSide : Float}
type Pos = {x : Float, y : Float, direction : Float}
type WheelObs = {speed : Float, angle : Float}
type SensorData = {estDist : Float, maxRange : Float, sigma : Float, obs : Float}

// TODO(larshum, 2023-03-06): Which (external) functions can we use from within
// an RTPPL program?
const pi : Float = 4.0 * atan(1.0)

const maxLongRangeSensorDist : Float = 4.0
const maxShortRangeSensorDist : Float = 2.0

// Distance sensor offsets on the car
const frontLeftOfs : Pos = {x = 0.0-0.05, y = 0.235, direction = 0.0}
const frontRightOfs : Pos = {x = 0.05, y = 0.235, direction = 0.0}
const rearLeftOfs : Pos = {x = 0.0-0.11, y = 0.0-0.28, direction = pi}
const rearRightOfs : Pos = {x = 0.11, y = 0.0-0.28, direction = pi}
const sideLeftOfs : Pos = {x = 0.0-0.105, y = 0.0-0.07, direction = (0.0-pi) / 2.0}
const sideRightOfs : Pos = {x = 0.105, y = 0.0-0.07, direction = pi / 2.0}

// Determines whether the given coordinate is within the bounds of the map.
def withinBounds(m : RoomMap, p : Pos) : Bool {
  var xc : Int = floorfi(p.x / m.sqSide)
  var yc : Int = floorfi(p.y / m.sqSide)
  if (xc >= 0 && xc < m.cols) && (yc >= 0 && yc < m.rows) {
    return m.sq[xc][yc]
  } else {
    return false
  }
}

// Collects the free squares of the room, i.e. those that are not obstructed by
// walls or other obstacles.
def findFreeSquares(m : RoomMap) : [Pos] {
  var fs : [Pos] = []
  for i in range(0, m.rows) {
    for j in range(0, m.cols) {
      if m.sq[i][j] {
        push(fs, {x = i * m.sqSide, y = j * m.sqSide, direction = 0})
      } else {}
    }
  }
  return fs
}

/////////////////////////////////
// INITIAL POSITION ESTIMATION //
/////////////////////////////////

// Choose a random free position on the map, as an initial guess. We defer the
// choice of direction until the next estimation, when we have distance
// observations. Otherwise, we risk rejecting good position estimates because
// we happened to pick a bad initial direction.
def initialPosition(m : RoomMap) : Pos {
  var free : [Pos] = findFreeSquares(m)
  var c : Pos = free[rand() % length(free)]
  var x : Float = assumeGaussian(c.x, c.x + m.sqSide)
  var y : Float = assumeGaussian(c.y, c.y + m.sqSide)
  return {x = x, y = y, direction = 0.0}
}

// Given the x- and y-coordinates, we choose the most likely direction among a
// fixed set of angles, for the provided distance observations.
def estimateDirection(di : DistanceInputs, m : RoomMap, d : Dist(Pos)) : Pos {
  var p0 : Pos = assume(d)
  var angles : [Float] = [pi / 2.0, pi, (3.0 * pi) / 4.0]

  var w : Float = observationModel(di, m, p0)
  for d in angles {
    var p : Pos = p0
    p.direction = d
    var pw : Float = observationModel(di, m, p)
    if pw > w {
      p0 = p
      w = pw
    } else {}
  }
  weight(pw)
  return p0
}

//////////////////////
// TRANSITION MODEL //
//////////////////////

// Reads the observations we got from the wheel sensors. In this version, we
// assume all wheel observations are made synchronously, and otherwise we
// reject them.
def readWheelObservations(wheelInputs : WheelInputs) : [TSV(WheelObs)] {
  var leftSpeeds : [TSV(Float)] = wheelInputs.sl
  var rightSpeeds : [TSV(Float)] = wheelInputs.sr
  var steeringAngles : [TSV(Float)] = wheelInputs.sa

  var observations : [TSV(WheelObs)] = []
  var n : Int = min([length(leftSpeeds), length(rightSpeeds), length(steeringAngles)])
  for i in range(0, n) {
    var ls : TSV(Float) = leftSpeeds[i]
    var rs : TSV(Float) = rightSpeeds[i]
    var sa : TSV(Float) = steeringAngles[i]
    var ts : Timestamp = tsvTimestamp(ls)
    if ts == tsvTimestamp(rs) && ts == tsvTimestamp(sa) {
      var avgSpeed : Float = (l + r) / 2.0
      var obs : TSV(WheelObs) = tsv({speed = avgSpeed, angle = tsvValue(sa)}, ts)
      push(observations, obs)
    } else {}
  }
  return observations
}

// Estimate the next position, assuming the car is driving at constant speed
// and steering angle from the time of the previous position estimate until the
// time at which we made the current wheel observations.
def estimateNextPosition(obs : TSV(WheelObs), p : TSV(Pos)) : TSV(Pos) {
  var wo : WheelObs = tsvValue(obs)
  var p : Pos = tsvValue(p)
  var v : Float = assumeGaussian(wo.speed, 0.01)
  var a : Float = assumeGaussian(wo.angle, 0.05)
  var obsTime : Float = tsvTimestamp(obs)
  var dist : Float = v * (obsTime - tsvTimestamp(p))
  var direction : Float = (dist * tan(a)) / 0.45
  var x : Float = p.x + dist * cos(direction)
  var y : Float = p.y + dist * sin(direction)
  return tsv({x = x, y = y, direction = direction}, tsvTimestamp(obsTime))
}

// Compute the "new" position based on the observations provided by the wheel
// sensors.
def transitionModel(wi : WheelInputs, p0 : Pos, t : Timestamp) : [TSV(Pos)] {
  var wheelObs : WheelObs = readWheelObservations(wi)
  var positions : [Pos] = [tsv(p0, t)]
  for obs in wheelObs {
    var newPos : Pos = estimateNextPosition(obs, positions[0-1])
    positions = push(positions, newPos)
  }
  return positions
}

///////////////////////
// OBSERVATION MODEL //
///////////////////////

// Finds the estimated position whose associated timestamp is the closest to
// the provided timestamp, i.e. the position we expect to most closely match
// the given timestamp.
def minTimestampDiff(positions : [TSV(Pos)], ts : Timestamp) : TSV(Pos) {
  var n : Int = length(positions)
  if n == 0 {
    error("Empty array")
  } else {

  }
  var minp : Pos = positions[0]
  var d : Float = abs(tsvTimestamp(minp) - ts)
  for i in range(1, n) {
    var di : Float = abs(tsvTimestamp(positions[i]) - ts)
    if di < d {
      minp = positions[i]
      d = di
    } else {}
  }
  return minp
}

def positionPlusOffset(p : Pos, ofs : Pos) : Pos {
  return {
    x = p.x + ofs.x,
    y = p.y + ofs.y,
    direction = p.direction + ofs.direction
  }
}

// Estimates the expected distance a sensor should observe when the car is at a
// given position.
def estimateDistance(m : RoomMap, p : Pos, ofs : Pos) : Float {
  var p : Pos = positionPlusOffset(p, ofs)
  var eps : Float = 0.05
  var distTravelled : Float = 0.0
  loop {
    if withinBounds(m, p) {
        var x : Float = p.x + eps * cos(p.direction)
        var y : Float = p.y + eps * sin(p.direction)
        // TODO: How do we translate mutability to MExpr? Such code will not
        // work in Miking DPPL.
        p = {x = x, y = y, direction = p.direction}
        distTravelled = distTravelled + eps
    } else {
      // TODO: should we support breaking? This could be equivalently expressed
      // using a while-loop
      break
    }
  }
  return distTravelled
}

// Given the median observation of a sensor, estimate the distance it should
// have observed, assuming it was at the position closest in time to one of the
// estimated positions from the transition model.
def estimateSensorDistance(m : RoomMap, positions : [TSV(Pos)],
                           obs : TSV(Float), sensorOffset : Pos) : Float {
  var p : Pos = tsvValue(minTimestampDiff(positions, tsvTimestamp(obs)))
  return estimateDistance(m, p, sensorOffset)
}

def cmpTs(l : TSV(Pos), r : TSV(Pos)) : Int {
  var lt : Float = tsvTimestamp(l)
  var rt : Float = tsvTimestamp(r)
  if lt > rt {
    return 1
  } else {
    if lt < rt {
      return 0-1
    } else {
      return 0
    }
  }
}

// TODO: How would we define a generic function, such as for sorting?
// def sort<T>(v : [T], cmp : T -> T -> Int) : [T] { ... }

def median(v : [TSV(Pos)]) : TSV(Pos) {
  var n : Int = length(v)
  if n % 2 == 0 {
    error("How do we combine two timestamps?")
  } else {}
  // TODO: this call implicitly uses a higher-order function, is that supported?
  var vs : [TSV(Pos)] = sort(v, cmpTs)
  return vs[n / 2]
}

def observationModel(distanceInputs : DistanceInputs, m : RoomMap,
                     positions : [TSV(Pos)]) : Float {
  var w : Float = 1.0
  // TODO: This could be expressed more nicely using higher-order functions.
  var distanceSensors : [SensorData] = [
    { estDist = estimateSensorDistance(m, positions, distanceInputs.fl, frontLeftOfs)
    , maxRange = maxLongRangeSensorDist, sigma = 0.1, obs = tsvValue(distanceInputs.fl) },
    { estDist = estimateSensorDistance(m, positions, distanceInputs.fr, frontRightOfs)
    , maxRange = maxLongRangeSensorDist, sigma = 0.1, obs = tsvValue(distanceInputs.fr) },
    { estDist = estimateSensorDistance(m, positions, distanceInputs.rl, rearLeftOfs)
    , maxRange = maxLongRangeSensorDist, sigma = 0.1, obs = tsvValue(distanceInputs.rl) },
    { estDist = estimateSensorDistance(m, positions, distanceInputs.rr, rearRightOfs)
    , maxRange = maxLongRangeSensorDist, sigma = 0.1, obs = tsvValue(distanceInputs.rr) },
    { estDist = estimateSensorDistance(m, positions, distanceInputs.sl, sideLeftOfs)
    , maxRange = maxShortRangeSensorDist, sigma = 0.05, obs = tsvValue(distanceInputs.sl) },
    { estDist = estimateSensorDistance(m, positions, distanceInputs.sr, sideRightOfs)
    , maxRange = maxShortRangeSensorDist, sigma = 0.05, obs = tsvValue(distanceInputs.sr) }
  ]
  for s in distanceSensors {
    if s.obs < s.maxRange {
      w = w * gaussianLogPdf(e, s.sigma, s.obs)
    } else {
      if s.estDist < s.maxRange {
        w = 0
        // TODO: it would make sense to stop iterating here, if we support the
        // break statement
        break
      } else {}
    }
  }
  return w
}

////////////////////////////
// MAIN POSITIONING MODEL //
////////////////////////////

// TODO: The current version returns the position corresponding to the time at
// which we made the most recent wheel observation, which will lead to
// inaccuracy. It should either use an estimate of the position at the current
// or the next arrival time (either at the current logical timestamp or the
// next one).
def positionModel(di : DistanceInputs, wi : WheelInputs, m : RoomMap,
                  d : Dist(Pos)) : Pos {
  var p0 : Dist(Pos) = assume(d)
  var t : Timestamp = getLogicalTimestamp()
  var positions : [TSV(Pos)] = transitionModel(wi, p0, t)
  for tpos in positions {
    if not(withinBounds(m, tpos)) {
      weight(0)
    } else {}
  }
  weight(observationModel(di, m, positions))
  return positions[0-1]
}

def positioning(m : RoomMap, period : Float) : Unit {
  input dfl : Float
  input dfr : Float
  input drl : Float
  input drr : Float
  input dsl : Float
  input dsr : Float
  input wsl : Float
  input wsr : Float
  input wsa : Float
  output pos : Dist(Float)

  var distanceInputs : DistanceInputs = {
    fl = median(readChannel(dfl)),
    fr = median(readChannel(dfr)),
    rl = median(readChannel(drl)),
    rr = median(readChannel(drr)),
    sl = median(readChannel(dsl)),
    sr = median(readChannel(dsr))
  }
  var wheelInputs : WheelInputs = {
    ls = readChannel(wsl),
    rs = readChannel(wsr),
    sa = readChannel(wsa)
  }

  var d : Dist(Pos) = infer(initialPosition(m))
  writeChannel(pos, d)
  sdelay(period)
  d = infer(estimateDirection(distanceInputs, m, d))
  writeChannel(pos, d)
  loop {
    sdelay(period)
    d = infer(positionModel(distanceInputs, wheelInputs, m, d))
    writeChannel(pos, d)
  }
}

//////////////////
// BRAKING TASK //
//////////////////

// TODO: Preferably, this task would not be periodic, but rather it would wake
// up as soon as it gets a position estimate from the positioning task. Also,
// it should be able to "schedule" a message to be sent at a future time.
def brake(period : Float) : Unit {
  input pos : Dist(Float)
  output brake : Bool

  // TODO: implement
  loop {
    sdelay(period)
  }
}

main() {
  task p = positioning(m, 500)
  task b = brake(100)

  distanceFrontLeft -> p.dfl
  distanceFrontRight -> p.dfr
  distanceRearLeft -> p.drl
  distanceRearRight -> p.drr
  distanceSideLeft -> p.dsl
  distanceSideRight -> p.dsr
  wheelSpeedLeft -> p.wsl
  wheelSpeedRight -> p.wsr
  wheelSteeringAngle -> p.wsa
  p.pos -> b.pos
  b.brake -> wheelBrake
}
